[{"title":"mybatis","path":"/2024/06/18/mybatis/","content":"MyBatis mybatis 中文手册 一、MyBatis概述1.1 框架●在文献中看到的framework被翻译为框架 ●Java常用框架： ○SSM三大框架：Spring + SpringMVC + MyBatis ○SpringBoot ○SpringCloud等。 ●框架其实就是对通用代码的封装，提前写好了一堆接口和类，我们可以在做项目的时候直接引入这些接口和类（引入框架），基于这些现有的接口和类进行开发，可以大大提高开发效率。 ●什么东西都给你弄好了，具体的业务你在自己往上写补充好了就行了！！！！！ ●框架一般都以jar包的形式存在。(jar包中有class文件以及各种配置文件等。) ●SSM三大框架的学习顺序：MyBatis、Spring、SpringMVC（仅仅是建议） 1.2 三层架构 ●表现层（UI）：直接跟前端打交互（一是接收前端ajax请求，二是返回json数据给前端） ●业务逻辑层（BLL）：一是处理表现层转发过来的前端请求（也就是具体业务），二是将从持久层获取的数据返回到表现层。 ●数据访问层（DAL）：直接操作数据库完成CRUD，并将获得的数据返回到上一层（也就是业务逻辑层）。 ●Java持久层框架： ​\t○MyBatis ​\t○Hibernate（实现了JPA规范） ​\t○jOOQ ​\t○Guzz ​\t○Spring Data（实现了JPA规范） ​\t○ActiveJDBC ​\t○…… 1.3 JDBC不足●示例代码1： 1234567891011121314151617181920// ......// sql语句写死在java程序中String sql = &quot;insert into t_user(id,idCard,username,password,birth,gender,email,city,street,zipcode,phone,grade) values(?,?,?,?,?,?,?,?,?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 繁琐的赋值：思考一下，这种有规律的代码能不能通过反射机制来做自动化。ps.setString(1, &quot;1&quot;);ps.setString(2, &quot;123456789&quot;);ps.setString(3, &quot;zhangsan&quot;);ps.setString(4, &quot;123456&quot;);ps.setString(5, &quot;1980-10-11&quot;);ps.setString(6, &quot;男&quot;);ps.setString(7, &quot;zhangsan@126.com&quot;);ps.setString(8, &quot;北京&quot;);ps.setString(9, &quot;大兴区凉水河二街&quot;);ps.setString(10, &quot;1000000&quot;);ps.setString(11, &quot;16398574152&quot;);ps.setString(12, &quot;A&quot;);// 执行SQLint count = ps.executeUpdate();// ...... ●示例代码2： 12345678910111213141516171819202122232425262728293031323334353637383940// ......// sql语句写死在java程序中String sql = &quot;select id,idCard,username,password,birth,gender,email,city,street,zipcode,phone,grade from t_user&quot;;PreparedStatement ps = conn.prepareStatement(sql);ResultSet rs = ps.executeQuery();List&lt;User&gt; userList = new ArrayList&lt;&gt;();// 思考以下循环中的所有代码是否可以使用反射进行自动化封装。while(rs.next())&#123; // 获取数据 String id = rs.getString(&quot;id&quot;); String idCard = rs.getString(&quot;idCard&quot;); String username = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); String birth = rs.getString(&quot;birth&quot;); String gender = rs.getString(&quot;gender&quot;); String email = rs.getString(&quot;email&quot;); String city = rs.getString(&quot;city&quot;); String street = rs.getString(&quot;street&quot;); String zipcode = rs.getString(&quot;zipcode&quot;); String phone = rs.getString(&quot;phone&quot;); String grade = rs.getString(&quot;grade&quot;); // 创建对象 User user = new User(); // 给对象属性赋值 user.setId(id); user.setIdCard(idCard); user.setUsername(username); user.setPassword(password); user.setBirth(birth); user.setGender(gender); user.setEmail(email); user.setCity(city); user.setStreet(street); user.setZipcode(zipcode); user.setPhone(phone); user.setGrade(grade); // 添加到集合 userList.add(user);&#125;// ...... ●JDBC不足： ​ ○SQL语句写死在Java程序中，不灵活。改SQL的话就要改Java代码。违背开闭原则OCP。 ​ ○给?传值是繁琐的。能不能自动化？？？ ​ ○将结果集封装成Java对象是繁琐的。能不能自动化？？？ 1.4 了解MyBatis●MyBatis本质上就是对JDBC的封装，通过MyBatis完成CRUD。 ●MyBatis在三层架构中负责持久层的，属于持久层框架。 ●MyBatis的发展历程：【引用百度百科】 ​ ○MyBatis本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github。 ​ ○iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）。 ●打开mybatis代码可以看到它的包结构中包含：ibatis ​ ○ ●ORM：对象关系映射 ​ ○O（Object）：Java虚拟机中的Java对象 ​ ○R（Relational）：关系型数据库 ​ ○M（Mapping）：将Java虚拟机中的Java对象映射到数据库表中一行记录，或是将数据库表中一行记录映射成Java虚拟机中的一个Java对象。 ​ ○ORM图示 ​ ■ ​ ■ ​ ○MyBatis属于半自动化ORM框架。 ​ ■sql 语句需要我们自己写 ​ ○Hibernate属于全自动化的ORM框架。 ​ ■大部分sql 语句不需要我们自己写，但是写好的sql 语句可能很大程度上不是我们需要的，也需要我们自己根据业务自己封装新的 ​ 001-ORM思想-对象关系映射 ●MyBatis框架特点： ​ ○支持定制化 SQL、存储过程、基本映射以及高级映射 ​ ○避免了几乎所有的 JDBC 代码中手动设置参数以及获取结果集 ​ ○支持XML开发，也支持注解式开发。【为了保证sql语句的灵活，所以mybatis大部分是采用XML方式开发。】 ​ ○将接口和 Java 的 POJOs(Plain Ordinary Java Object，简单普通的Java对象)映射成数据库中的记录 ​ ○体积小好学：两个jar包，两个XML配置文件。 ​ ○完全做到sql解耦合。 ​ ○提供了基本映射标签。 ​ ○提供了高级映射标签。 ​ ○提供了XML标签，支持动态SQL的编写。 ​ ○…… 二、MyBatis入门程序只要你会JDBC，MyBatis就可以学。 2.1 版本软件版本： IntelliJ IDEA：2022.1.4 Navicat for MySQL：16.0.14 MySQL数据库：8.0.30 组件版本： MySQL驱动：8.0.3 0 MyBatis：3.5.10 JDK：Java17 JUnit：4.13.2 Logback：1.2.11 2.2 MyBatis下载 从github上下载，地址：https://github.com/mybatis/mybatis-3 将框架以及框架的源码都下载下来，下载框架后解压，打开mybatis目录 通过以上解压可以看到，框架一般都是以jar包的形式存在。我们的mybatis课程使用maven，所以这个jar我们不需要。 官方手册需要。 2.3 MyBatis入门程序开发步骤 写代码前准备： 准备数据库表：汽车表t_car，字段包括： id：主键（自增）【bigint】 car_num：汽车编号【varchar】 brand：品牌【varchar】 guide_price：厂家指导价【decimal类型，专门为财务数据准备的类型】 produce_time：生产时间【char，年月日即可，10个长度，’2022-10-11’】 car_type：汽车类型（燃油车、电车、氢能源）【varchar】 使用navicat for mysql工具建表 使用navicat for mysql工具向t_car表中插入两条数据，如下： 创建Project：建议创建Empty Project，设置Java版本以及编译版本等。 设置IDEA的maven 创建Module：普通的Maven Java模块 步骤1：打包方式：jar（不需要war，因为mybatis封装的是jdbc。） 1234&lt;groupId&gt;com.powernode&lt;/groupId&gt;&lt;artifactId&gt;mybatis-001-introduction&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 步骤2：引入依赖（mybatis依赖 + mysql驱动依赖） 123456789101112&lt;!--mybatis核心依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.10&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt;&lt;/dependency&gt; 步骤3：在resources根目录下新建mybatis-config.xml配置文件（可以参考mybatis手册拷贝） 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--sql映射文件创建好之后，需要将该文件路径配置到这里--&gt; &lt;mapper resource=&quot;&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意1：mybatis核心配置文件的文件名不一定是mybatis-config.xml，可以是其它名字。 注意2：mybatis核心配置文件存放的位置也可以随意。这里选择放在resources根下，相当于放到了类的根路径下。 步骤4：在resources根目录下新建CarMapper.xml配置文件（可以参考mybatis手册拷贝） 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace先随意写一个--&gt;&lt;mapper namespace=&quot;car&quot;&gt; &lt;!--insert sql：保存一个汽车信息--&gt; &lt;insert id=&quot;insertCar&quot;&gt; insert into t_car (id,car_num,brand,guide_price,produce_time,car_type) values (null,&#x27;102&#x27;,&#x27;丰田mirai&#x27;,40.30,&#x27;2014-10-05&#x27;,&#x27;氢能源&#x27;) &lt;/insert&gt;&lt;/mapper&gt; 注意1：sql语句最后结尾可以不写“;” 注意2：CarMapper.xml文件的名字不是固定的。可以使用其它名字。 12345678910111213&lt;mappers&gt; &lt;!--执行XxxMapper.xml文件的路径--&gt; &lt;!--resource属性自动会从类的根路径下开始查找资源。--&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;!--resource属性：从类路径当中加载资源。--&gt; &lt;!--&lt;mapper resource=&quot;com/CarMapper2.xml&quot;/&gt;--&gt; &lt;!--url属性：从绝对路径当中加载资源。--&gt; &lt;!--语法格式：file:///绝对路径--&gt; &lt;!--不建议：因为移植性差。--&gt; &lt;!--&lt;mapper url=&quot;file:///d:/CarMapper.xml&quot;/&gt;--&gt; &lt;!--&lt;mapper resource=&quot;com/CarMapper.xml&quot;/&gt;--&gt;&lt;/mappers&gt; 注意3：CarMapper.xml文件的位置也是随意的。这里选择放在resources根下，相当于放到了类的根路径下。 注意4：将CarMapper.xml文件路径配置到mybatis-config.xml： 1&lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; 步骤5：编写MyBatisIntroductionTest代码 123456789101112131415161718192021222324252627282930313233343536373839package com.powernode.mybatis.test;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.FileInputStream;import java.io.InputStream;public class MyBatisIntroductionTest &#123; public static void main(String[] args) throws Exception &#123; // 获取SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 获取SqlSessionFactory对象 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // Resources.getResourceAsStream默认就是从类的根路径下开始查找资源。 //InputStream is = Resources.getResourceAsStream(&quot;com/mybatis.xml&quot;); //InputStream is = new FileInputStream(&quot;d:\\\\mybatis-config.xml&quot;); //InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); // 一般情况下都是一个数据库对应一个SqlSessionFactory对象。 // 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 如果使用的事务管理器是JDBC的话，底层实际上会执行：conn.setAutoCommit(false); // 这种方式实际上是不建议的，因为没有开启事务。 //SqlSession sqlSession = sqlSessionFactory.openSession(true); // 执行SQL语句 int count = sqlSession.insert(&quot;insertCar&quot;); // 返回值是影响数据库表当中的记录条数。 System.out.println(&quot;插入了几条记录：&quot; + count); // 手动提交 sqlSession.commit(); // 如果使用的事务管理器是JDBC的话，底层实际上还是会执行conn.commit(); &#125;&#125; 注意1：默认采用的事务管理器是：JDBC。JDBC事务默认是不提交的，需要手动提交。 1234567891011121314151617181920212223242526272829303132333435363738396. 关于mybatis的事务管理机制。（深度剖析） * 在mybatis-config.xml文件中，可以通过以下的配置进行mybatis的事务管理 &lt;transactionManager type=&quot;JDBC&quot;/&gt; * type属性的值包括两个： JDBC(jdbc) MANAGED(managed) type后面的值，只有以上两个值可选，不区分大小写。 * 在mybatis中提供了两种事务管理机制： 第一种：JDBC事务管理器 第二种：MANAGED事务管理器 * JDBC事务管理器： mybatis框架自己管理事务，自己采用原生的JDBC代码去管理事务： conn.setAutoCommit(false); 开启事务。 ....业务处理... conn.commit(); 手动提交事务 使用JDBC事务管理器的话，底层创建的事务管理器对象：JdbcTransaction对象。 如果你编写的代码是下面的代码： SqlSession sqlSession = sqlSessionFactory.openSession(true); 表示没有开启事务。因为这种方式压根不会执行：conn.setAutoCommit(false); 在JDBC事务中，没有执行conn.setAutoCommit(false);那么autoCommit就是true。 如果autoCommit是true，就表示没有开启事务。只要执行任意一条DML语句就提交一次。 * MANAGED事务管理器： mybatis不再负责事务的管理了。事务管理交给其它容器来负责。例如：spring。 我不管事务了，你来负责吧。 对于我们当前的单纯的只有mybatis的情况下，如果配置为：MANAGED 那么事务这块是没人管的。没有人管理事务表示事务压根没有开启。 没有人管理事务就是没有事务。 * JDBC中的事务： 如果你没有在JDBC代码中执行：conn.setAutoCommit(false);的话，默认的autoCommit是true。 * 重点： 以后注意了，只要你的autoCommit是true，就表示没有开启事务。 只有你的autoCommit是false的时候，就表示开启了事务。 步骤6：运行程序，查看运行结果，以及数据库表中的数据 步骤总结：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155开发我的第一个MyBatis程序1. resources目录： 放在这个目录当中的，一般都是资源文件，配置文件。 直接放到resources目录下的资源，等同于放到了类 的根路径下。2. 开发步骤* 第一步：打包方式jar* 第二步：引入依赖 - mybatis依赖 - mysql驱动依赖* 第三步：编写mybatis核心配置文件：mybatis-config.xml 注意： 第一：这个文件名不是必须叫做mybatis-config.xml，可以用其他的名字。只是大家都采用这个名字。 第二：这个文件存放的位置也不是固定的，可以随意，但一般情况下，会放到类的根路径下。 mybatis-config.xml文件中的配置信息不理解没关系，先把连接数据库的信息修改以下即可。 其他的别动。* 第四步：编写XxxxMapper.xml文件 在这个配置文件当中编写SQL语句。 这个文件名也不是固定的，放的位置也不是固定，我们这里给它起个名字，叫做：CarMapper.xml 把它暂时放到类的根路径下。* 第五步：在mybatis-config.xml文件中指定XxxxMapper.xml文件的路径： &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; 注意：resource属性会自动从类的根路径下开始查找资源。* 第六步：编写MyBatis程序。(使用mybatis的类库，编写mybatis程序，连接数据库，做增删改查就行了。) 在MyBatis当中，负责执行SQL语句的那个对象叫做什么呢？ SqlSession SqlSession是专门用来执行SQL语句的，是一个Java程序和数据库之间的一次会话。 要想获取SqlSession对象，需要先获取SqlSessionFactory对象，通过SqlSessionFactory工厂来生产SqlSession对象。 怎么获取SqlSessionFactory对象呢？ 需要首先获取SqlSessionFactoryBuilder对象。 通过SqlSessionFactoryBuilder对象的build方法，来获取一个SqlSessionFactory对象。 mybatis的核心对象包括： SqlSessionFactoryBuilder SqlSessionFactory SqlSession SqlSessionFactoryBuilder --&gt; SqlSessionFactory --&gt; SqlSession3. 从 XML 中构建 SqlSessionFactory 通过官方的这句话，你能想到什么呢？ 第一：在MyBatis中一定是有一个很重要的对象，这个对象是：SqlSessionFactory对象。 第二：SqlSessionFactory对象的创建需要XML。 XML是什么？ 它一定是一个配置文件。4. mybatis中有两个主要的配置文件： 其中一个是：mybatis-config.xml，这是核心配置文件，主要配置连接数据库的信息等。（一个） 另一个是：XxxxMapper.xml，这个文件是专门用来编写SQL语句的配置文件。（一个表一个） t_user表，一般会对应一个UserMapper.xml t_student表，一般会对应一个StudentMapper.xml5. 关于第一个程序的小细节 * mybatis中sql语句的结尾&quot;;&quot;可以省略。 * Resources.getResourceAsStream 小技巧：以后凡是遇到resource这个单词，大部分情况下，这种加载资源的方式就是从类的根路径下开始加载。（开始查找） 优点：采用这种方式，从类路径当中加载资源，项目的移植性很强。项目从windows移植到linux，代码不需要修改，因为这个资源文件一直都在类路径当中。 * InputStream is = new FileInputStream(&quot;d:\\\\mybatis-config.xml&quot;); 采用这种方式也可以。 缺点：可移植性太差，程序不够健壮。可能会移植到其他的操作系统当中。导致以上路径无效，还需要修改java代码中的路径。这样违背了OCP原则。 * 已经验证了： mybatis核心配置文件的名字，不一定是：mybatis-config.xml。可以是其它名字。 mybatis核心配置文件存放的路径，也不一定是在类的根路径下。可以放到其它位置。但为了项目的移植性，健壮性，最好将这个配置文件放到类路径下面。 * InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;mybatis-config.xml&quot;); ClassLoader.getSystemClassLoader() 获取系统的类加载器。 系统类加载器有一个方法叫做：getResourceAsStream 它就是从类路径当中加载资源的。 通过源代码分析发现： InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); 底层的源代码其实就是： InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;mybatis-config.xml&quot;); * CarMapper.xml文件的名字是固定的吗？CarMapper.xml文件的路径是固定的吗？ 都不是固定的。 &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; resource属性：这种方式是从类路径当中加载资源。 &lt;mapper url=&quot;file:///d:/CarMapper.xml&quot;/&gt; url属性：这种方式是从绝对路径当中加载资源。6. 关于mybatis的事务管理机制。（深度剖析） * 在mybatis-config.xml文件中，可以通过以下的配置进行mybatis的事务管理 &lt;transactionManager type=&quot;JDBC&quot;/&gt; * type属性的值包括两个： JDBC(jdbc) MANAGED(managed) type后面的值，只有以上两个值可选，不区分大小写。 * 在mybatis中提供了两种事务管理机制： 第一种：JDBC事务管理器 第二种：MANAGED事务管理器 * JDBC事务管理器： mybatis框架自己管理事务，自己采用原生的JDBC代码去管理事务： conn.setAutoCommit(false); 开启事务。 ....业务处理... conn.commit(); 手动提交事务 使用JDBC事务管理器的话，底层创建的事务管理器对象：JdbcTransaction对象。 如果你编写的代码是下面的代码： SqlSession sqlSession = sqlSessionFactory.openSession(true); 表示没有开启事务。因为这种方式压根不会执行：conn.setAutoCommit(false); 在JDBC事务中，没有执行conn.setAutoCommit(false);那么autoCommit就是true。 如果autoCommit是true，就表示没有开启事务。只要执行任意一条DML语句就提交一次。 * MANAGED事务管理器： mybatis不再负责事务的管理了。事务管理交给其它容器来负责。例如：spring。 我不管事务了，你来负责吧。 对于我们当前的单纯的只有mybatis的情况下，如果配置为：MANAGED 那么事务这块是没人管的。没有人管理事务表示事务压根没有开启。 没有人管理事务就是没有事务。 * JDBC中的事务： 如果你没有在JDBC代码中执行：conn.setAutoCommit(false);的话，默认的autoCommit是true。 * 重点： 以后注意了，只要你的autoCommit是true，就表示没有开启事务。 只有你的autoCommit是false的时候，就表示开启了事务。7. 关于mybatis集成日志组件。让我们调试起来更加方便。 * mybatis常见的集成的日志组件有哪些呢？ SLF4J（沙拉风）：沙拉风是一个日志标准，其中有一个框架叫做logback，它实现了沙拉风规范。 LOG4J LOG4J2 STDOUT_LOGGING .... 注意：log4j log4j2 logback都是同一个作者开发的。 * 其中STDOUT_LOGGING是标准日志，mybatis已经实现了这种标准日志。mybatis框架本身已经实现了这种标准。 只要开启即可。怎么开启呢？在mybatis-config.xml文件中使用settings标签进行配置开启。 &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; 这个标签在编写的时候要注意，它应该出现在environments标签之前。注意顺序。当然，不需要记忆这个顺序。 因为有dtd文件进行约束呢。我们只要参考dtd约束即可。 这种实现也是可以的，可以看到一些信息，比如：连接对象什么时候创建，什么时候关闭，sql语句是怎样的。 但是没有详细的日期，线程名字，等。如果你想使用更加丰富的配置，可以集成第三方的log组件。 * 集成logback日志框架。 logback日志框架实现了slf4j标准。(沙拉风：日志门面。日志标准。) 第一步：引入logback的依赖。 &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; 第二步：引入logback所必须的xml配置文件。 这个配置文件的名字必须叫做：logback.xml或者logback-test.xml，不能是其它的名字。 这个配置文件必须放到类的根路径下。不能是其他位置。 主要配置日志输出相关的级别以及日志具体的格式。 2.4 关于MyBatis核心配置文件的名字和路径详解 核心配置文件的名字是随意的，因为以下的代码： 12// 文件名是出现在程序中的，文件名如果修改了，对应这里的java程序也改一下就行了。InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;mybatis-config.xml&quot;); 核心配置文件必须放到resources下吗？放到D盘根目录下，可以吗？测试一下： 将mybatis-config.xml文件拷贝一份放到D盘根下，然后编写以下程序： 12345678910111213141516171819202122232425262728package com.powernode.mybatis;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.FileInputStream;import java.io.InputStream;public class MyBatisConfigFilePath &#123; public static void main(String[] args) throws Exception&#123; // 1. 创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2. 创建SqlSessionFactory对象 // 这只是一个输入流，可以自己new。 InputStream is = new FileInputStream(&quot;D:/mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); // 3. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 4. 执行sql int count = sqlSession.insert(&quot;insertCar&quot;); System.out.println(&quot;插入几条数据：&quot; + count); // 5. 提交（mybatis默认采用的事务管理器是JDBC，默认是不提交的，需要手动提交。） sqlSession.commit(); // 6. 关闭资源（只关闭是不会提交的） sqlSession.close(); &#125;&#125; 以上程序运行后，看到数据库表t_car中又新增一条数据，如下（成功了）： 经过测试说明mybatis核心配置文件的名字是随意的，存放路径也是随意的。 虽然mybatis核心配置文件的名字不是固定的，但通常该文件的名字叫做：mybatis-config.xml 虽然mybatis核心配置文件的路径不是固定的，但通常该文件会存放到类路径当中，这样让项目的移植更加健壮。 在mybatis中提供了一个类：Resources【org.apache.ibatis.io.Resources】，该类可以从类路径当中获取资源，我们通常使用它来获取输入流InputStream，代码如下 12// 这种方式只能从类路径当中获取资源，也就是说mybatis-config.xml文件需要在类路径下。InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); 2.5 MyBatis第一个比较完整的代码写法1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.powernode.mybatis;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;/** * 比较完整的第一个mybatis程序写法 * @author 老杜 * @since 1.0 * @version 1.0 */public class MyBatisCompleteCodeTest &#123; public static void main(String[] args) &#123; SqlSession sqlSession = null; try &#123; // 1.创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); // 3.创建SqlSession对象 sqlSession = sqlSessionFactory.openSession(); // 4.执行SQL int count = sqlSession.insert(&quot;insertCar&quot;); System.out.println(&quot;更新了几条记录：&quot; + count); // 5.提交 sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚 if (sqlSession != null) &#123; sqlSession.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 6.关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; 运行后数据库表的变化： 2.6 引入JUnit JUnit是专门做单元测试的组件。 在实际开发中，单元测试一般是由我们Java程序员来完成的。 我们要对我们自己写的每一个业务方法负责任，要保证每个业务方法在进行测试的时候都能通过。 测试的过程中涉及到两个概念： 期望值 实际值 期望值和实际值相同表示测试通过，期望值和实际值不同则单元测试执行时会报错。 这里引入JUnit是为了代替main方法。 使用JUnit步骤： 第一步：引入依赖 1234567&lt;!-- junit依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 第二步：编写单元测试类【测试用例】，测试用例中每一个测试方法上使用@Test注解进行标注。 测试用例的名字以及每个测试方法的定义都是有规范的： 测试用例的名字：XxxTest 测试方法声明格式：public void test业务方法名(){} 1234567891011// 测试用例public class CarMapperTest&#123; // 测试方法 @Test public void testInsert()&#123;&#125; @Test public void testUpdate()&#123;&#125; &#125; 第三步：可以在类上执行，也可以在方法上执行 在类上执行时，该类中所有的测试方法都会执行。 在方法上执行时，只执行当前的测试方法。 编写一个测试用例，来测试insertCar业务 123456789101112131415161718192021222324252627282930313233343536373839package com.powernode.mybatis;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;public class CarMapperTest &#123; @Test public void testInsertCar()&#123; SqlSession sqlSession = null; try &#123; // 1.创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); // 3.创建SqlSession对象 sqlSession = sqlSessionFactory.openSession(); // 4.执行SQL int count = sqlSession.insert(&quot;insertCar&quot;); System.out.println(&quot;更新了几条记录：&quot; + count); // 5.提交 sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚 if (sqlSession != null) &#123; sqlSession.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 6.关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; 执行单元测试，查看数据库表的变化： 2.7 引入日志框架logback 引入日志框架的目的是为了看清楚mybatis执行的具体sql。 启用标准日志组件，只需要在mybatis-config.xml文件中添加以下配置：【可参考mybatis手册】 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;&lt;/settings&gt; 标准日志也可以用，但是配置不够灵活，可以集成其他的日志组件，例如：log4j，logback等。 logback是目前日志框架中性能较好的，较流行的，所以我们选它。 引入logback的步骤： 第一步：引入logback相关依赖 123456&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 第二步：引入logback相关配置文件（文件名叫做logback.xml或logback-test.xml，放到类路径当中） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot;&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt; &lt;MaxFileSize&gt;100MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!--mybatis log configure--&gt; &lt;logger name=&quot;com.apache.ibatis&quot; level=&quot;TRACE&quot;/&gt; &lt;logger name=&quot;java.sql.Connection&quot; level=&quot;DEBUG&quot;/&gt; &lt;logger name=&quot;java.sql.Statement&quot; level=&quot;DEBUG&quot;/&gt; &lt;logger name=&quot;java.sql.PreparedStatement&quot; level=&quot;DEBUG&quot;/&gt; &lt;!-- 日志输出级别,logback日志级别包括五个：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;appender-ref ref=&quot;FILE&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 再次执行单元测试方法testInsertCar，查看控制台是否有sql语句输出 2.8 MyBatis工具类SqlSessionUtil的封装 每一次获取SqlSession对象代码太繁琐，封装一个工具类 SqlSessionFactory对象：一个SqlSessionFactory对应一个environment，一个environment通常是一个数据库。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;environments default=&quot;development&quot;&gt; &lt;!--对应不同的环境，以每个数据库为主，每种数据库都可以配置很多数据库，--&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;package com.powernode.mybatis.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;/** * MyBatis工具类 * @author 动力节点 * @version 1.0 * @since 1.0 */public class SqlSessionUtil &#123; // 工具类的构造方法一般都是私有化的。 // 工具类中所有的方法都是静态的，直接采用类名即可调用。不需要new对象。 // 为了防止new对象，构造方法私有化。 private SqlSessionUtil()&#123;&#125; private static SqlSessionFactory sqlSessionFactory; // 类加载时执行 // SqlSessionUtil工具类在进行第一次加载的时候，解析mybatis-config.xml文件。创建SqlSessionFactory对象。 static &#123; try &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; /*public static SqlSession openSession()&#123; SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // SqlSessionFactory对象：一个SqlSessionFactory对应一个environment，一个environment通常是一个数据库。 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125;*/ /** * 获取会话对象。 * @return 会话对象 */ public static SqlSession openSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 测试工具类，将testInsertCar()改造 12345678@Testpublic void testInsertCar()&#123; SqlSession sqlSession = SqlSessionUtil.openSession(); // 执行SQL int count = sqlSession.insert(&quot;insertCar&quot;); System.out.println(&quot;插入了几条记录:&quot; + count); sqlSession.close();&#125; 三、使用MyBatis完成CRUD123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192使用mybatis完成CRUD1. 什么是CRUD C: Create增 R: Retrieve查（检索） U: Update改 D: Delete删2. insert &lt;insert id=&quot;insertCar&quot;&gt; insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,&#x27;1003&#x27;,&#x27;丰田霸道&#x27;,30.0,&#x27;2000-10-11&#x27;,&#x27;燃油车&#x27;); &lt;/insert&gt; 这样写的问题是？ 值 显然是写死到配置文件中的。 这个在实际开发中是不存在的。 一定是前端的form表单提交过来数据。然后将值传给sql语句。 例如：JDBC的代码是怎么写的？ String sql = &quot;insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,?,?,?,?,?)&quot;; ps.setString(1, xxx); ps.setString(2, yyy); .... 在JDBC当中占位符采用的是?，在mybatis当中是什么呢？ 和?等效的写法是：#&#123;&#125; 在mybatis当中不能使用?占位符，必须使用 #&#123;&#125; 来代替JDBC当中的 ? #&#123;&#125; 和 JDBC当中的 ? 是等效的。 java程序中使用Map可以给SQL语句的占位符传值： Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;k1&quot;, &quot;1111&quot;); map.put(&quot;k2&quot;, &quot;比亚迪汉&quot;); map.put(&quot;k3&quot;, 10.0); map.put(&quot;k4&quot;, &quot;2020-11-11&quot;); map.put(&quot;k5&quot;, &quot;电车&quot;); insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,#&#123;k1&#125;,#&#123;k2&#125;,#&#123;k3&#125;,#&#123;k4&#125;,#&#123;k5&#125;); 注意：#&#123;这里写什么？写map集合的key，如果key不存在，获取的是null&#125; 一般map集合的key起名的时候要见名知意。 map.put(&quot;carNum&quot;, &quot;1111&quot;); map.put(&quot;brand&quot;, &quot;比亚迪汉2&quot;); map.put(&quot;guidePrice&quot;, 10.0); map.put(&quot;produceTime&quot;, &quot;2020-11-11&quot;); map.put(&quot;carType&quot;, &quot;电车&quot;); insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;); java程序中使用POJO类给SQL语句的占位符传值： Car car = new Car(null, &quot;3333&quot;, &quot;比亚迪秦&quot;, 30.0, &quot;2020-11-11&quot;, &quot;新能源&quot;); 注意：占位符#&#123;&#125;，大括号里面写：pojo类的属性名 insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;) 把SQL语句写成这个德行： insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,#&#123;xyz&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;) 出现了什么问题呢？ There is no getter for property named &#x27;xyz&#x27; in &#x27;class com.powernode.mybatis.pojo.Car&#x27; mybatis去找：Car类中的getXyz()方法去了。没找到。报错了。 怎么解决的？ 可以在Car类中提供一个getXyz()方法。这样问题就解决了。 通过这个测试，得出一个结论： 严格意义上来说：如果使用POJO对象传递值的话，#&#123;&#125;这个大括号中到底写什么？ 写的是get方法的方法名去掉get，然后将剩下的单词首字母小写，然后放进去。 例如：getUsername() --&gt; #&#123;username&#125; 例如：getEmail() --&gt; #&#123;email&#125; .... 也就是说mybatis在底层给?传值的时候，先要获取值，怎么获取的？ 调用了pojo对象的get方法。例如：car.getCarNum()，car.getCarType()，car.getBrand()3. delete * 需求：根据id删除数据 将id=59的数据删除。 实现： int count = sqlSession.delete(&quot;deleteById&quot;, 59); &lt;delete id=&quot;deleteById&quot;&gt; delete from t_car where id = #&#123;fdsfd&#125; &lt;/delete&gt; 注意：如果占位符只有一个，那么#&#123;&#125;的大括号里可以随意。但是最好见名知意。4. update * 需求：根据id修改某条记录。 实现： &lt;update id=&quot;updateById&quot;&gt; update t_car set car_num=#&#123;carNum&#125;, brand=#&#123;brand&#125;, guide_price=#&#123;guidePrice&#125;, produce_time=#&#123;produceTime&#125;, car_type=#&#123;carType&#125; where id = #&#123;id&#125; &lt;/update&gt; Car car = new Car(4L, &quot;9999&quot;, &quot;凯美瑞&quot;, 30.3, &quot;1999-11-10&quot;, &quot;燃油车&quot;); int count = sqlSession.update(&quot;updateById&quot;, car);5. select（查一个，根据主键查询的话，返回的结果一定是一个。） * 需求：根据id查询。 实现： &lt;select id=&quot;selectById&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select * from t_car where id = #&#123;id&#125; &lt;/select&gt; Object car = sqlSession.selectOne(&quot;selectById&quot;, 1); 需要特别注意的是： select标签中resultType属性，这个属性用来告诉mybatis，查询结果集封装成什么类型的java对象。你需要告诉mybatis。 resultType通常写的是：全限定类名。 Car&#123;id=1, carNum=&#x27;null&#x27;, brand=&#x27;宝马520Li&#x27;, guidePrice=null, produceTime=&#x27;null&#x27;, carType=&#x27;null&#x27;&#125; 输出结果有点不对劲： id和brand属性有值。 其他属性为null。 carNum以及其他的这几个属性没有赋上值的原因是什么？ select * from t_car where id = 1 执行结果： +----+---------+-----------+-------------+--------------+----------+ | id | car_num | brand | guide_price | produce_time | car_type | +----+---------+-----------+-------------+--------------+----------+ | 1 | 1001 | 宝马520Li | 10.00 | 2020-10-11 | 燃油车 | +----+---------+-----------+-------------+--------------+----------+ car_num、guide_price、produce_time、car_type这是查询结果的列名。 这些列名和Car类中的属性名对不上。 Car类的属性名： carNum、guidePrice、produceTime、carType 那这个问题怎么解决呢？ select语句查询的时候，查询结果集的列名是可以使用as关键字起别名的。 &lt;select id=&quot;selectById&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car where id = #&#123;id&#125; &lt;/select&gt; 起别名之后： +----+--------+-----------+------------+-------------+---------+ | id | carNum | brand | guidePrice | produceTime | carType | +----+--------+-----------+------------+-------------+---------+ | 1 | 1001 | 宝马520Li | 10.00 | 2020-10-11 | 燃油车 | +----+--------+-----------+------------+-------------+---------+6. select（查所有的） &lt;select id=&quot;selectAll&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car &lt;/select&gt; List&lt;Object&gt; cars = sqlSession.selectList(&quot;selectAll&quot;); 注意：resultType还是指定要封装的结果集的类型。不是指定List类型，是指定List集合中元素的类型。 selectList方法：mybatis通过这个方法就可以得知你需要一个List集合。它会自动给你返回一个List集合。7. 在sql mapper.xml文件当中有一个namespace,这个属性是用来指定命名空间的。用来防止id重复。怎么用？ 在xml文件中： &lt;mapper namespace=&quot;aaaaaaaaa&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice, produce_time as produceTime, car_type from t_car &lt;/select&gt; &lt;/mapper&gt; 在java程序中的写法： List&lt;Object&gt; cars = sqlSession.selectList(&quot;aaaaaaaaa.selectAll&quot;); 实际上，本质上，mybatis中的sqlId的完整写法： namespace.id 三、使用MyBatis完成CRUD 准备工作 创建module（Maven的普通Java模块）：mybatis-002-crud pom.xml 打包方式jar 依赖： mybatis依赖 mysql驱动依赖 junit依赖 logback依赖 mybatis-config.xml放在类的根路径下 CarMapper.xml放在类的根路径下 logback.xml放在类的根路径下 提供com.powernode.mybatis.utils.SqlSessionUtil工具类 创建测试用例：com.powernode.mybatis.CarMapperTest 3.1 insert（Create）分析以下SQL映射文件中SQL语句存在的问题 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace先随便写--&gt;&lt;mapper namespace=&quot;car&quot;&gt; &lt;insert id=&quot;insertCar&quot;&gt; insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(&#x27;103&#x27;, &#x27;奔驰E300L&#x27;, 50.3, &#x27;2022-01-01&#x27;, &#x27;燃油车&#x27;) &lt;/insert&gt;&lt;/mapper&gt; 存在的问题是：SQL语句中的值不应该写死，值应该是用户提供的。之前的JDBC代码是这样写的： 123456789// JDBC中使用 ? 作为占位符。那么MyBatis中会使用什么作为占位符呢？String sql = &quot;insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(?,?,?,?,?)&quot;;// ......// 给 ? 传值。那么MyBatis中应该怎么传值呢？ps.setString(1,&quot;103&quot;);ps.setString(2,&quot;奔驰E300L&quot;);ps.setDouble(3,50.3);ps.setString(4,&quot;2022-01-01&quot;);ps.setString(5,&quot;燃油车&quot;); 在MyBatis中可以这样做： 在Java程序中，将数据放到Map集合中 在sql语句中使用 #{map集合的key} 来完成传值，#{} 等同于JDBC中的 ? ，#{}就是占位符 Java程序这样写： 1234567891011121314151617181920212223242526272829303132package com.powernode.mybatis;import com.powernode.mybatis.utils.SqlSessionUtil;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.HashMap;import java.util.Map;/** * 测试MyBatis的CRUD * @author 老杜 * @version 1.0 * @since 1.0 */public class CarMapperTest &#123; @Test public void testInsertCar()&#123; // 准备数据 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;k1&quot;, &quot;103&quot;); map.put(&quot;k2&quot;, &quot;奔驰E300L&quot;); map.put(&quot;k3&quot;, 50.3); map.put(&quot;k4&quot;, &quot;2020-10-01&quot;); map.put(&quot;k5&quot;, &quot;燃油车&quot;); // 获取SqlSession对象 SqlSession sqlSession = SqlSessionUtil.openSession(); // 执行SQL语句（使用map集合给sql语句传递数据） int count = sqlSession.insert(&quot;insertCar&quot;, map); System.out.println(&quot;插入了几条记录：&quot; + count); &#125;&#125; SQL语句这样写： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace先随便写--&gt;&lt;mapper namespace=&quot;car&quot;&gt; &lt;insert id=&quot;insertCar&quot;&gt; insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(#&#123;k1&#125;,#&#123;k2&#125;,#&#123;k3&#125;,#&#123;k4&#125;,#&#123;k5&#125;) &lt;/insert&gt;&lt;/mapper&gt; #{} 的里面必须填写map集合的key，不能随便写。运行测试程序，查看数据库： 如果#{}里写的是map集合中不存在的key会有什么问题？ 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;car&quot;&gt; &lt;insert id=&quot;insertCar&quot;&gt; insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(#&#123;kk&#125;,#&#123;k2&#125;,#&#123;k3&#125;,#&#123;k4&#125;,#&#123;k5&#125;) &lt;/insert&gt;&lt;/mapper&gt; 运行程序： 通过测试，看到程序并没有报错。正常执行。不过 #{kk} 的写法导致无法获取到map集合中的数据，最终导致数据库表car_num插入了NULL。 在以上sql语句中，可以看到#{k1} #{k2} #{k3} #{k4} #{k5}的可读性太差，为了增强可读性，我们可以将Java程序做如下修改： 1234567Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();// 让key的可读性增强map.put(&quot;carNum&quot;, &quot;103&quot;);map.put(&quot;brand&quot;, &quot;奔驰E300L&quot;);map.put(&quot;guidePrice&quot;, 50.3);map.put(&quot;produceTime&quot;, &quot;2020-10-01&quot;);map.put(&quot;carType&quot;, &quot;燃油车&quot;); SQL语句做如下修改，这样可以增强程序的可读性： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;car&quot;&gt; &lt;insert id=&quot;insertCar&quot;&gt; insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;) &lt;/insert&gt;&lt;/mapper&gt; 运行程序，查看数据库表： 使用Map集合可以传参，那使用pojo（简单普通的java对象）可以完成传参吗？测试一下： 第一步：定义一个pojo类Car，提供相关属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.powernode.mybatis.pojo;/** * POJOs，简单普通的Java对象。封装数据用的。 * @author 老杜 * @version 1.0 * @since 1.0 */public class Car &#123; private Long id; private String carNum; private String brand; private Double guidePrice; private String produceTime; private String carType; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;id=&quot; + id + &quot;, carNum=&#x27;&quot; + carNum + &#x27;\\&#x27;&#x27; + &quot;, brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; + &quot;, guidePrice=&quot; + guidePrice + &quot;, produceTime=&#x27;&quot; + produceTime + &#x27;\\&#x27;&#x27; + &quot;, carType=&#x27;&quot; + carType + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Car() &#123; &#125; public Car(Long id, String carNum, String brand, Double guidePrice, String produceTime, String carType) &#123; this.id = id; this.carNum = carNum; this.brand = brand; this.guidePrice = guidePrice; this.produceTime = produceTime; this.carType = carType; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getCarNum() &#123; return carNum; &#125; public void setCarNum(String carNum) &#123; this.carNum = carNum; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public Double getGuidePrice() &#123; return guidePrice; &#125; public void setGuidePrice(Double guidePrice) &#123; this.guidePrice = guidePrice; &#125; public String getProduceTime() &#123; return produceTime; &#125; public void setProduceTime(String produceTime) &#123; this.produceTime = produceTime; &#125; public String getCarType() &#123; return carType; &#125; public void setCarType(String carType) &#123; this.carType = carType; &#125;&#125; 第二步：Java程序 123456789101112131415@Testpublic void testInsertCarByPOJO()&#123; // 创建POJO，封装数据 Car car = new Car(); car.setCarNum(&quot;103&quot;); car.setBrand(&quot;奔驰C200&quot;); car.setGuidePrice(33.23); car.setProduceTime(&quot;2020-10-11&quot;); car.setCarType(&quot;燃油车&quot;); // 获取SqlSession对象 SqlSession sqlSession = SqlSessionUtil.openSession(); // 执行SQL，传数据 int count = sqlSession.insert(&quot;insertCarByPOJO&quot;, car); System.out.println(&quot;插入了几条记录&quot; + count);&#125; 第三步：SQL语句 1234&lt;insert id=&quot;insertCarByPOJO&quot;&gt; &lt;!--#&#123;&#125; 里写的是POJO的属性名--&gt; insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;)&lt;/insert&gt; 运行程序，查看数据库表： #{} 里写的是POJO的属性名，如果写成其他的会有问题吗？ 123&lt;insert id=&quot;insertCarByPOJO&quot;&gt; insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(#&#123;a&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;)&lt;/insert&gt; 运行程序，出现了以下异常： 错误信息中描述：在Car类中没有找到a属性的getter方法。 修改POJO类Car的代码，只将getCarNum()方法名修改为getA()，其他代码不变，如下： 再运行程序，查看数据库表中数据： 经过测试得出结论： 如果采用map集合传参，#{} 里写的是map集合的key，如果key不存在不会报错，数据库表中会插入NULL。 如果采用POJO传参，#{} 里写的是get方法的方法名去掉get之后将剩下的单词首字母变小写（例如：getAge对应的是#{age}，getUserName对应的是#{userName}），如果这样的get方法不存在会报错。 注意：其实传参数的时候有一个属性parameterType，这个属性用来指定传参的数据类型，不过这个属性是可以省略的 1234567&lt;insert id=&quot;insertCar&quot; parameterType=&quot;java.util.Map&quot;&gt; insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;)&lt;/insert&gt;&lt;insert id=&quot;insertCarByPOJO&quot; parameterType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; insert into t_car(car_num,brand,guide_price,produce_time,car_type) values(#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;)&lt;/insert&gt; 3.2 delete（Delete）需求：根据car_num进行删除。 SQL语句这样写： 123&lt;delete id=&quot;deleteByCarNum&quot;&gt; delete from t_car where car_num = #&#123;SuiBianXie&#125;&lt;/delete&gt; Java程序这样写： 12345678@Testpublic void testDeleteByCarNum()&#123; // 获取SqlSession对象 SqlSession sqlSession = SqlSessionUtil.openSession(); // 执行SQL语句 int count = sqlSession.delete(&quot;deleteByCarNum&quot;, &quot;102&quot;); System.out.println(&quot;删除了几条记录：&quot; + count);&#125; 运行结果： 注意：当占位符只有一个的时候，#{} 里面的内容可以随便写。 3.3 update（Update）需求：修改id&#x3D;34的Car信息，car_num为102，brand为比亚迪汉，guide_price为30.23，produce_time为2018-09-10，car_type为电车 修改前： SQL语句如下： 1234567&lt;update id=&quot;updateCarByPOJO&quot;&gt; update t_car set car_num = #&#123;carNum&#125;, brand = #&#123;brand&#125;, guide_price = #&#123;guidePrice&#125;, produce_time = #&#123;produceTime&#125;, car_type = #&#123;carType&#125; where id = #&#123;id&#125;&lt;/update&gt; Java代码如下： 12345678910111213141516@Testpublic void testUpdateCarByPOJO()&#123; // 准备数据 Car car = new Car(); car.setId(34L); car.setCarNum(&quot;102&quot;); car.setBrand(&quot;比亚迪汉&quot;); car.setGuidePrice(30.23); car.setProduceTime(&quot;2018-09-10&quot;); car.setCarType(&quot;电车&quot;); // 获取SqlSession对象 SqlSession sqlSession = SqlSessionUtil.openSession(); // 执行SQL语句 int count = sqlSession.update(&quot;updateCarByPOJO&quot;, car); System.out.println(&quot;更新了几条记录：&quot; + count);&#125; 运行结果： 当然了，如果使用map传数据也是可以的。 3.4 select（Retrieve）select语句和其它语句不同的是：查询会有一个结果集。来看mybatis是怎么处理结果集的！！！ 查询一条数据需求：查询id为1的Car信息 SQL语句如下： 123&lt;select id=&quot;selectCarById&quot;&gt; select * from t_car where id = #&#123;id&#125;&lt;/select&gt; Java程序如下： 12345678@Testpublic void testSelectCarById()&#123; // 获取SqlSession对象 SqlSession sqlSession = SqlSessionUtil.openSession(); // 执行SQL语句 Object car = sqlSession.selectOne(&quot;selectCarById&quot;, 1); System.out.println(car);&#125; 运行结果如下： 12345### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement &#x27;car.selectCarById&#x27;. 【翻译】：对于一个查询语句来说，没有找到查询的结果映射。 It&#x27;s likely that neither a Result Type nor a Result Map was specified. 【翻译】：很可能既没有指定结果类型，也没有指定结果映射。 以上的异常大致的意思是：对于一个查询语句来说，你需要指定它的“结果类型”或者“结果映射”。 所以说，你想让mybatis查询之后返回一个Java对象的话，至少你要告诉mybatis返回一个什么类型的Java对象，可以在标签中添加resultType属性，用来指定查询要转换的类型： 123&lt;select id=&quot;selectCarById&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select * from t_car where id = #&#123;id&#125;&lt;/select&gt; 运行结果： 运行后之前的异常不再出现了，这说明添加了resultType属性之后，解决了之前的异常，可以看出resultType是不能省略的。 仔细观察控制台的日志信息，不难看出，结果查询出了一条。并且每个字段都查询到值了： Row: 1, 100, 宝马520Li, 41.00, 2022-09-01, 燃油车 但是奇怪的是返回的Car对象，只有id和brand两个属性有值，其它属性的值都是null，这是为什么呢？我们来观察一下查询结果列名和Car类的属性名是否能一一对应： 查询结果集的列名：id, car_num, brand, guide_price, produce_time, car_type Car类的属性名：id, carNum, brand, guidePrice, produceTime, carType 通过观察发现：只有id和brand是一致的，其他字段名和属性名对应不上，这是不是导致null的原因呢？我们尝试在sql语句中使用as关键字来给查询结果列名起别名试试： 12345678&lt;select id=&quot;selectCarById&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id, car_num as carNum, brand, guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car where id = #&#123;id&#125;&lt;/select&gt; 运行结果如下： 通过测试得知，如果当查询结果的字段名和java类的属性名对应不上的话，可以采用as关键字起别名，当然还有其它解决方案，我们后面再看。 查询多条数据需求：查询所有的Car信息。 SQL语句如下： 12345678&lt;!--虽然结果是List集合，但是resultType属性需要指定的是List集合中元素的类型。--&gt;&lt;select id=&quot;selectCarAll&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; &lt;!--记得使用as起别名，让查询结果的字段名和java类的属性名对应上。--&gt; select id, car_num as carNum, brand, guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car&lt;/select&gt; Java代码如下： 123456789@Testpublic void testSelectCarAll()&#123; // 获取SqlSession对象 SqlSession sqlSession = SqlSessionUtil.openSession(); // 执行SQL语句 List&lt;Object&gt; cars = sqlSession.selectList(&quot;selectCarAll&quot;); // 输出结果 cars.forEach(car -&gt; System.out.println(car));&#125; 运行结果如下： 3.5 关于SQL Mapper的namespace在SQL Mapper配置文件中标签的namespace属性可以翻译为命名空间，这个命名空间主要是为了防止sqlId冲突的。 创建CarMapper2.xml文件，代码如下： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;car2&quot;&gt; &lt;select id=&quot;selectCarAll&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id, car_num as carNum, brand, guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car &lt;/select&gt;&lt;/mapper&gt; 不难看出，CarMapper.xml和CarMapper2.xml文件中都有 id&#x3D;”selectCarAll” 将CarMapper2.xml配置到mybatis-config.xml文件中。 1234&lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;mapper resource=&quot;CarMapper2.xml&quot;/&gt;&lt;/mappers&gt; 编写Java代码如下： 123456789@Testpublic void testNamespace()&#123; // 获取SqlSession对象 SqlSession sqlSession = SqlSessionUtil.openSession(); // 执行SQL语句 List&lt;Object&gt; cars = sqlSession.selectList(&quot;selectCarAll&quot;); // 输出结果 cars.forEach(car -&gt; System.out.println(car));&#125; 运行结果如下： 12345org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: java.lang.IllegalArgumentException: selectCarAll is ambiguous in Mapped Statements collection (try using the full name including the namespace, or rename one of the entries) 【翻译】selectCarAll在Mapped Statements集合中不明确（请尝试使用包含名称空间的全名，或重命名其中一个条目） 【大致意思是】selectCarAll重名了，你要么在selectCarAll前添加一个名称空间，要有你改个其它名字。 Java代码修改如下： 12345678910@Testpublic void testNamespace()&#123; // 获取SqlSession对象 SqlSession sqlSession = SqlSessionUtil.openSession(); // 执行SQL语句 //List&lt;Object&gt; cars = sqlSession.selectList(&quot;car.selectCarAll&quot;); List&lt;Object&gt; cars = sqlSession.selectList(&quot;car2.selectCarAll&quot;); // 输出结果 cars.forEach(car -&gt; System.out.println(car));&#125; 运行结果如下： 四、MyBatis核心配置文件详解(重要)整体上看这个就行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--java.util.Properties类。是一个Map集合。key和value都是String类型--&gt; &lt;!--在properties标签中可以配置很多属性--&gt; &lt;!--&lt;properties&gt;--&gt; &lt;!--这是其中的一个属性--&gt; &lt;!--&lt;property name=&quot;属性名&quot; value=&quot;属性值&quot;/&gt;--&gt; &lt;!--&lt;property name=&quot;jdbc.driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbc.url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt;--&gt; &lt;!--&lt;/properties&gt;--&gt; &lt;!--resource,一定是从类路径下开始查找资源--&gt; &lt;properties resource=&quot;jdbc.properties&quot; /&gt; &lt;!--从绝对路径当中加载资源。绝对路径怎么写？file:///路径--&gt; &lt;!--&lt;properties url=&quot;file:///d:/jdbc.properties&quot; /&gt;--&gt; &lt;!--default表示默认使用的环境。--&gt; &lt;!--默认环境什么意思？当你使用mybatis创建SqlSessionFactory对象的时候，没有指定环境的话，默认使用哪个环境。--&gt; &lt;environments default=&quot;powernodeDB&quot;&gt; &lt;!--其中的一个环境。连接的数据库是powernode--&gt; &lt;!--一般一个数据库会对应一个SqlSessionFactory对象。--&gt; &lt;!--一个环境environment会对应一个SqlSessionFactory对象--&gt; &lt;environment id=&quot;powernodeDB&quot;&gt; &lt;!-- transactionManager标签： 1.作用：配置事务管理器。指定mybatis具体使用什么方式去管理事务。 2.type属性有两个值： 第一个：JDBC: 使用原生的JDBC代码来管理事务。 conn.setAutoCommit(false); .... conn.commit(); 第二个：MANAGED：mybatis不再负责事务的管理，将事务管理交给其它的JEE(JavaEE)容器来管理。例如：spring 3. 大小写无所谓。不缺分大小写。但是不能写其他值。只能是二选一： jdbc、managed 4. 在mybatis中提供了一个事务管理器接口：Transaction 该接口下有两个实现类： JdbcTransaction ManagedTransaction 如果type=&quot;JDBC&quot;，那么底层会实例化JdbcTransaction对象。 如果type=&quot;MANAGED&quot;，那么底层会实例化ManagedTransaction --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource配置： 1.dataSource被称为数据源。 2.dataSource作用是什么？为程序提供Connection对象。（但凡是给程序提供Connection对象的，都叫做数据源。） 3.数据源实际上是一套规范。JDK中有这套规范：javax.sql.DataSource（这个数据源的规范，这套接口实际上是JDK规定的。） 4.我们自己也可以编写数据源组件，只要实现javax.sql.DataSource接口就行了。实现接口当中所有的方法。这样就有了自己的数据源。 比如你可以写一个属于自己的数据库连接池（数据库连接池是提供连接对象的，所以数据库连接池就是一个数据源）。 5.常见的数据源组件有哪些呢【常见的数据库连接池有哪些呢】？ 阿里巴巴的德鲁伊连接池：druid c3p0 dbcp .... 6. type属性用来指定数据源的类型，就是指定具体使用什么方式来获取Connection对象： type属性有三个值：必须是三选一。 type=&quot;[UNPOOLED|POOLED|JNDI]&quot; UNPOOLED：不使用数据库连接池技术。每一次请求过来之后，都是创建新的Connection对象。 POOLED：使用mybatis自己实现的数据库连接池。 JNDI：集成其它第三方的数据库连接池。 JNDI是一套规范。谁实现了这套规范呢？大部分的web容器都实现了JNDI规范： 例如：Tomcat、Jetty、WebLogic、WebSphere，这些服务器(容器)都实现了JNDI规范。 JNDI是：java命名目录接口。Tomcat服务器实现了这个规范。 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!--提醒：正常使用连接池的话，池中有很多参数是需要设置的。设置好参数，可以让连接池发挥的更好。事半功倍的效果。--&gt; &lt;!--具体连接池当中的参数如何配置呢？需要反复的根据当前业务情况进行测试。--&gt; &lt;!--poolMaximumActiveConnections：连接池当中最多的正在使用的连接对象的数量上限。最多有多少个连接可以活动。默认值10--&gt; &lt;property name=&quot;poolMaximumActiveConnections&quot; value=&quot;10&quot;/&gt; &lt;!--每隔2秒打印日志，并且尝试获取连接对象--&gt; &lt;property name=&quot;poolTimeToWait&quot; value=&quot;2000&quot;/&gt; &lt;!--强行让某个连接空闲，超时时间的设置--&gt; &lt;property name=&quot;poolMaximumCheckoutTime&quot; value=&quot;10000&quot;/&gt; &lt;!--最多的空闲数量--&gt; &lt;property name=&quot;poolMaximumIdleConnections&quot; value=&quot;5&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!--这是mybatis的另一个环境，也就是连接的数据库是另一个数据库mybatis--&gt; &lt;environment id=&quot;mybatisDB&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 12345678910111213141516171819202122&lt;mybatis-config.xml&gt;&lt;/mybatis-config.xml&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;mapper resource=&quot;CarMapper2.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; configuration：根标签，表示配置信息。 environments：环境（多个），以“s”结尾表示复数，也就是说mybatis的环境可以配置多个数据源。 default属性：表示默认使用的是哪个环境，default后面填写的是environment的id。default的值只需要和environment的id值一致即可。 environment：具体的环境配置（主要包括：事务管理器的配置 + 数据源的配置） id：给当前环境一个唯一标识，该标识用在environments的default后面，用来指定默认环境的选择。 transactionManager：配置事务管理器 type属性：指定事务管理器具体使用什么方式，可选值包括两个 JDBC：使用JDBC原生的事务管理机制。底层原理：事务开启conn.setAutoCommit(false); …处理业务…事务提交conn.commit(); MANAGED：交给其它容器来管理事务，比如WebLogic、JBOSS等。如果没有管理事务的容器，则没有事务。没有事务的含义：只要执行一条DML语句，则提交一次。 dataSource：指定数据源 type属性：用来指定具体使用的数据库连接池的策略，可选值包括三个 UNPOOLED：采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想。 property可以是： driver 这是 JDBC 驱动的 Java 类全限定名。 url 这是数据库的 JDBC URL 地址。 username 登录数据库的用户名。 password 登录数据库的密码。 defaultTransactionIsolationLevel 默认的连接事务隔离级别。 defaultNetworkTimeout 等待数据库操作完成的默认网络超时时间（单位：毫秒） POOLED：采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现。 property可以是（除了包含UNPOOLED中之外）： poolMaximumActiveConnections 在任意时间可存在的活动（正在使用）连接数量，默认值：10 poolMaximumIdleConnections 任意时间可能存在的空闲连接数。 其它…. JNDI：采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。如果不是web或者maven的war工程，JNDI是不能使用的。 property可以是（最多只包含以下两个属性）： initial_context 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。 data_source 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。 mappers：在mappers标签中可以配置多个sql映射文件的路径。 mapper：配置某个sql映射文件的路径 resource属性：使用相对于类路径的资源引用方式 url属性：使用完全限定资源定位符（URL）方式 4.1 environment mybatis-003-configuration 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--默认使用开发环境--&gt; &lt;!--&lt;environments default=&quot;dev&quot;&gt;--&gt; &lt;!--默认使用生产环境--&gt; &lt;environments default=&quot;production&quot;&gt; &lt;!--开发环境--&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!--生产环境--&gt; &lt;environment id=&quot;production&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1234567891011CarMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;car&quot;&gt; &lt;insert id=&quot;insertCar&quot;&gt; insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;) &lt;/insert&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526272829303132333435363738package com.powernode.mybatis;import com.powernode.mybatis.pojo.Car;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;public class ConfigurationTest &#123; @Test public void testEnvironment() throws Exception&#123; // 准备数据 Car car = new Car(); car.setCarNum(&quot;133&quot;); car.setBrand(&quot;丰田霸道&quot;); car.setGuidePrice(50.3); car.setProduceTime(&quot;2020-01-10&quot;); car.setCarType(&quot;燃油车&quot;); // 一个数据库对应一个SqlSessionFactory对象 // 两个数据库对应两个SqlSessionFactory对象，以此类推 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 使用默认数据库 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(true); int count = sqlSession.insert(&quot;insertCar&quot;, car); System.out.println(&quot;插入了几条记录：&quot; + count); // 使用指定数据库 SqlSessionFactory sqlSessionFactory1 = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;), &quot;dev&quot;); SqlSession sqlSession1 = sqlSessionFactory1.openSession(true); int count1 = sqlSession1.insert(&quot;insertCar&quot;, car); System.out.println(&quot;插入了几条记录：&quot; + count1); &#125;&#125; 执行结果： 4.2 transactionManager 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;MANAGED&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789101112131415161718@Testpublic void testTransactionManager() throws Exception&#123; // 准备数据 Car car = new Car(); car.setCarNum(&quot;133&quot;); car.setBrand(&quot;丰田霸道&quot;); car.setGuidePrice(50.3); car.setProduceTime(&quot;2020-01-10&quot;); car.setCarType(&quot;燃油车&quot;); // 获取SqlSessionFactory对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config2.xml&quot;)); // 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行SQL int count = sqlSession.insert(&quot;insertCar&quot;, car); System.out.println(&quot;插入了几条记录：&quot; + count);&#125; 当事务管理器是：JDBC 采用JDBC的原生事务机制： 开启事务：conn.setAutoCommit(false); 处理业务…… 提交事务：conn.commit(); 当事务管理器是：MANAGED 交给容器去管理事务，但目前使用的是本地程序，没有容器的支持，当mybatis找不到容器的支持时：没有事务。也就是说只要执行一条DML语句，则提交一次。 4.3 dataSource ​ 连接池简单原理 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;UNPOOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1234567891011121314151617181920@Testpublic void testDataSource() throws Exception&#123; // 准备数据 Car car = new Car(); car.setCarNum(&quot;133&quot;); car.setBrand(&quot;丰田霸道&quot;); car.setGuidePrice(50.3); car.setProduceTime(&quot;2020-01-10&quot;); car.setCarType(&quot;燃油车&quot;); // 获取SqlSessionFactory对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config3.xml&quot;)); // 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); // 执行SQL int count = sqlSession.insert(&quot;insertCar&quot;, car); System.out.println(&quot;插入了几条记录：&quot; + count); // 关闭会话 sqlSession.close();&#125; 当type是UNPOOLED，控制台输出： 修改配置文件mybatis-config3.xml中的配置： 1&lt;dataSource type=&quot;POOLED&quot;&gt; Java测试程序不需要修改，直接执行，看控制台输出： 通过测试得出：UNPOOLED不会使用连接池，每一次都会新建JDBC连接对象。POOLED会使用数据库连接池。【这个连接池是mybatis自己实现的。】 1&lt;dataSource type=&quot;JNDI&quot;&gt; JNDI的方式：表示对接JNDI服务器中的连接池。这种方式给了我们可以使用第三方连接池的接口。如果想使用dbcp、c3p0、druid（德鲁伊）等，需要使用这种方式。 这种再重点说一下type&#x3D;”POOLED”的时候，它的属性有哪些？ 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;!--最大连接数--&gt; &lt;property name=&quot;poolMaximumActiveConnections&quot; value=&quot;3&quot;/&gt; &lt;!--这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。--&gt; &lt;property name=&quot;poolTimeToWait&quot; value=&quot;20000&quot;/&gt; &lt;!--强行回归池的时间--&gt; &lt;property name=&quot;poolMaximumCheckoutTime&quot; value=&quot;20000&quot;/&gt; &lt;!--最多空闲数量--&gt; &lt;property name=&quot;poolMaximumIdleConnections&quot; value=&quot;1&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; poolMaximumActiveConnections：最大的活动的连接数量。默认值10 poolMaximumIdleConnections：最大的空闲连接数量。默认值5 poolMaximumCheckoutTime：强行回归池的时间。默认值20秒。 poolTimeToWait：当无法获取到空闲连接时，每隔20秒打印一次日志，避免因代码配置有误，导致傻等。（时长是可以配置的） 当然，还有其他属性。对于连接池来说，以上几个属性比较重要。 最大的活动的连接数量就是连接池连接数量的上限。默认值10，如果有10个请求正在使用这10个连接，第11个请求只能等待空闲连接。 最大的空闲连接数量。默认值5，如何已经有了5个空闲连接，当第6个连接要空闲下来的时候，连接池会选择关闭该连接对象。来减少数据库的开销。 需要根据系统的并发情况，来合理调整连接池最大连接数以及最多空闲数量。充分发挥数据库连接池的性能。【可以根据实际情况进行测试，然后调整一个合理的数量。】 下图是默认配置： 在以上配置的基础之上，可以编写java程序测试： 123456789@Testpublic void testPool() throws Exception&#123; SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config3.xml&quot;)); for (int i = 0; i &lt; 4; i++) &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); Object selectCarByCarNum = sqlSession.selectOne(&quot;selectCarByCarNum&quot;); &#125;&#125; 123&lt;select id=&quot;selectCarByCarNum&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType from t_car where car_num = &#x27;100&#x27;&lt;/select&gt; 4.4 propertiesmybatis提供了更加灵活的配置，连接数据库的信息可以单独写到一个属性资源文件中，假设在类的根路径下创建jdbc.properties文件，配置如下： 12jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/powernode 在mybatis核心配置文件中引入并使用： 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入外部属性资源文件--&gt; &lt;properties resource=&quot;jdbc.properties&quot;&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt; &lt;/properties&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--$&#123;key&#125;使用--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写Java程序进行测试： 12345678@Testpublic void testProperties() throws Exception&#123; SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config4.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); Object car = sqlSession.selectOne(&quot;selectCarByCarNum&quot;); System.out.println(car);&#125; properties两个属性： resource：这个属性从类的根路径下开始加载。【常用的。】 url：从指定的url加载，假设文件放在d:&#x2F;jdbc.properties，这个url可以写成：file:&#x2F;&#x2F;&#x2F;d:&#x2F;jdbc.properties。注意是三个斜杠哦。 注意：如果不知道mybatis-config.xml文件中标签的编写顺序的话，可以有两种方式知道它的顺序： 第一种方式：查看dtd约束文件。 第二种方式：通过idea的报错提示信息。【一般采用这种方式】 4.5 mappermapper标签用来指定SQL映射文件的路径，包含多种指定方式，这里先主要看其中两种： 第一种：resource，从类的根路径下开始加载【比url常用】 123&lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt;&lt;/mappers&gt; 如果是这样写的话，必须保证类的根下有CarMapper.xml文件。 如果类的根路径下有一个包叫做test，CarMapper.xml如果放在test包下的话，这个配置应该是这样写： 123&lt;mappers&gt; &lt;mapper resource=&quot;test/CarMapper.xml&quot;/&gt;&lt;/mappers&gt; 第二种：url，从指定的url位置加载 假设CarMapper.xml文件放在d盘的根下，这个配置就需要这样写： 123&lt;mappers&gt; &lt;mapper url=&quot;file:///d:/CarMapper.xml&quot;/&gt;&lt;/mappers&gt; mapper还有其他的指定方式，后面再看！！！ 五、手写MyBatis框架（掌握原理）警示：该部分内容有难度，基础较弱的程序员可能有些部分是听不懂的，如果无法跟下来，可直接跳过，不影响后续知识点的学习。当然，如果你要能够跟下来，必然会让你加深对MyBatis框架的理解。 我们给自己的框架起个名：GodBatis（起名灵感来源于：my god!!! 我的天呢！） 5.1 dom4j解析XML文件该部分内容不再赘述，不会解析XML的，请观看老杜前面讲解的dom4j解析XML文件的视频。 模块名：parse-xml-by-dom4j（普通的Java Maven模块） 第一步：引入dom4j的依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.group&lt;/groupId&gt; &lt;artifactId&gt;parse-xml-by-dom4j&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!--dom4j依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--jaxen依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 第二步：编写配置文件godbatis-config.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;mappers&gt; &lt;mapper resource=&quot;sqlmapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/environments&gt;&lt;/configuration&gt; 第三步：解析godbatis-config.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.powernode.dom4j;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;import org.junit.Test;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 使用dom4j解析XML文件 */public class ParseXMLByDom4j &#123; @Test public void testGodBatisConfig() throws Exception&#123; // 读取xml，获取document对象 SAXReader saxReader = new SAXReader(); Document document = saxReader.read(Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;godbatis-config.xml&quot;)); // 获取&lt;environments&gt;标签的default属性的值 Element environmentsElt = (Element)document.selectSingleNode(&quot;/configuration/environments&quot;); String defaultId = environmentsElt.attributeValue(&quot;default&quot;); System.out.println(defaultId); // 获取environment标签 Element environmentElt = (Element)document.selectSingleNode(&quot;/configuration/environments/environment[@id=&#x27;&quot; + defaultId + &quot;&#x27;]&quot;); // 获取事务管理器类型 Element transactionManager = environmentElt.element(&quot;transactionManager&quot;); String transactionManagerType = transactionManager.attributeValue(&quot;type&quot;); System.out.println(transactionManagerType); // 获取数据源类型 Element dataSource = environmentElt.element(&quot;dataSource&quot;); String dataSourceType = dataSource.attributeValue(&quot;type&quot;); System.out.println(dataSourceType); // 将数据源信息封装到Map集合 Map&lt;String,String&gt; dataSourceMap = new HashMap&lt;&gt;(); dataSource.elements().forEach(propertyElt -&gt; &#123; dataSourceMap.put(propertyElt.attributeValue(&quot;name&quot;), propertyElt.attributeValue(&quot;value&quot;)); &#125;); dataSourceMap.forEach((k, v) -&gt; System.out.println(k + &quot;:&quot; + v)); // 获取sqlmapper.xml文件的路径 Element mappersElt = (Element) document.selectSingleNode(&quot;/configuration/environments/mappers&quot;); mappersElt.elements().forEach(mapper -&gt; &#123; System.out.println(mapper.attributeValue(&quot;resource&quot;)); &#125;); &#125;&#125; 执行结果： 第四步：编写配置文件sqlmapper.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;mapper namespace=&quot;car&quot;&gt; &lt;insert id=&quot;insertCar&quot;&gt; insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;) &lt;/insert&gt; &lt;select id=&quot;selectCarByCarNum&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType from t_car where car_num = #&#123;carNum&#125; &lt;/select&gt;&lt;/mapper&gt; 第五步：解析sqlmapper.xml 1234567891011121314151617181920212223242526272829@Testpublic void testSqlMapper() throws Exception&#123; // 读取xml，获取document对象 SAXReader saxReader = new SAXReader(); Document document = saxReader.read(Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;sqlmapper.xml&quot;)); // 获取namespace Element mapperElt = (Element) document.selectSingleNode(&quot;/mapper&quot;); String namespace = mapperElt.attributeValue(&quot;namespace&quot;); System.out.println(namespace); // 获取sql id mapperElt.elements().forEach(statementElt -&gt; &#123; // 标签名 String name = statementElt.getName(); System.out.println(&quot;name:&quot; + name); // 如果是select标签，还要获取它的resultType if (&quot;select&quot;.equals(name)) &#123; String resultType = statementElt.attributeValue(&quot;resultType&quot;); System.out.println(&quot;resultType:&quot; + resultType); &#125; // sql id String id = statementElt.attributeValue(&quot;id&quot;); System.out.println(&quot;sqlId:&quot; + id); // sql语句 String sql = statementElt.getTextTrim(); System.out.println(&quot;sql:&quot; + sql); &#125;);&#125; 执行结果： 5.2 GodBatis手写框架之前，如果没有思路，可以先参考一下mybatis的客户端程序，通过客户端程序来逆推需要的类，参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Testpublic void testInsert()&#123; SqlSession sqlSession = null; try &#123; // 1.创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); // 3.创建SqlSession对象 sqlSession = sqlSessionFactory.openSession(); // 4.执行SQL Car car = new Car(null, &quot;111&quot;, &quot;宝马X7&quot;, &quot;70.3&quot;, &quot;2010-10-11&quot;, &quot;燃油车&quot;); int count = sqlSession.insert(&quot;insertCar&quot;,car); System.out.println(&quot;更新了几条记录：&quot; + count); // 5.提交 sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚 if (sqlSession != null) &#123; sqlSession.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 6.关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125;@Testpublic void testSelectOne()&#123; SqlSession sqlSession = null; try &#123; // 1.创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); // 3.创建SqlSession对象 sqlSession = sqlSessionFactory.openSession(); // 4.执行SQL Car car = (Car)sqlSession.selectOne(&quot;selectCarByCarNum&quot;, &quot;111&quot;); System.out.println(car); // 5.提交 sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚 if (sqlSession != null) &#123; sqlSession.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 6.关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 第一步：IDEA中创建模块模块：godbatis（创建普通的Java Maven模块，打包方式jar），引入相关依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.god&lt;/groupId&gt; &lt;artifactId&gt;godbatis&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!--dom4j依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--jaxen依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 第二步：资源工具类，方便获取指向配置文件的输入流123456789101112131415161718192021package org.god.core;import java.io.InputStream;/** * 资源工具类 * @author 老杜 * @version 1.0 * @since 1.0 */public class Resources &#123; /** * 从类路径中获取配置文件的输入流 * @param config * @return 输入流，该输入流指向类路径中的配置文件 */ public static InputStream getResourcesAsStream(String config)&#123; return Thread.currentThread().getContextClassLoader().getResourceAsStream(config); &#125;&#125; 第三步：定义SqlSessionFactoryBuilder类提供一个无参数构造方法，再提供一个build方法，该build方法要返回SqlSessionFactory对象 12345678910111213141516171819202122232425262728293031323334package org.god.core;import java.io.InputStream;/** * SqlSessionFactory对象构建器 * @author 老杜 * @version 1.0 * @since 1.0 */public class SqlSessionFactoryBuilder &#123; /** * 创建构建器对象 */ public SqlSessionFactoryBuilder() &#123; &#125; /** * 获取SqlSessionFactory对象 * 该方法主要功能是：读取godbatis核心配置文件，并构建SqlSessionFactory对象 * @param inputStream 指向核心配置文件的输入流 * @return SqlSessionFactory对象 */ public SqlSessionFactory build(InputStream inputStream)&#123; // 解析配置文件，创建数据源对象 // 解析配置文件，创建事务管理器对象 // 解析配置文件，获取所有的SQL映射对象 // 将以上信息封装到SqlSessionFactory对象中 // 返回 return null; &#125;&#125; 第四步：分析SqlSessionFactory类中有哪些属性 事务管理器 GodJDBCTransaction SQL映射对象集合 Map&lt;String, GodMappedStatement&gt; 第五步：定义GodJDBCTransaction事务管理器最好是定义一个接口，然后每一个具体的事务管理器都实现这个接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package org.god.core;import java.sql.Connection;/** * 事务管理器接口 * @author 老杜 * @version 1.0 * @since 1.0 */public interface TransactionManager &#123; /** * 提交事务 */ void commit(); /** * 回滚事务 */ void rollback(); /** * 关闭事务 */ void close(); /** * 开启连接 */ void openConnection(); /** * 获取连接对象 * @return 连接对象 */ Connection getConnection();&#125;package org.god.core;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;/** * 事务管理器 * @author 老杜 * @version 1.0 * @since 1.0 */public class GodJDBCTransaction implements TransactionManager &#123; /** * 连接对象，控制事务时需要 */ private Connection conn; /** * 数据源对象 */ private DataSource dataSource; /** * 自动提交标志： * true表示自动提交 * false表示不自动提交 */ private boolean autoCommit; /** * 构造事务管理器对象 * @param autoCommit */ public GodJDBCTransaction(DataSource dataSource, boolean autoCommit) &#123; this.dataSource = dataSource; this.autoCommit = autoCommit; &#125; /** * 提交事务 */ public void commit()&#123; try &#123; conn.commit(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 回滚事务 */ public void rollback()&#123; try &#123; conn.rollback(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public void close() &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public void openConnection() &#123; try &#123; this.conn = dataSource.getConnection(); this.conn.setAutoCommit(this.autoCommit); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public Connection getConnection() &#123; return conn; &#125;&#125; 第六步：事务管理器中需要数据源，定义GodUNPOOLEDDataSource1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package org.god.core;import java.io.PrintWriter;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.logging.Logger;/** * 数据源实现类，不使用连接池 * @author 老杜 * @version 1.0 * @since 1.0 */public class GodUNPOOLEDDataSource implements javax.sql.DataSource&#123; private String url; private String username; private String password; public GodUNPOOLEDDataSource(String driver, String url, String username, String password) &#123; try &#123; // 注册驱动 Class.forName(driver); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; this.url = url; this.username = username; this.password = password; &#125; @Override public Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, username, password); &#125; @Override public Connection getConnection(String username, String password) throws SQLException &#123; return null; &#125; @Override public PrintWriter getLogWriter() throws SQLException &#123; return null; &#125; @Override public void setLogWriter(PrintWriter out) throws SQLException &#123; &#125; @Override public void setLoginTimeout(int seconds) throws SQLException &#123; &#125; @Override public int getLoginTimeout() throws SQLException &#123; return 0; &#125; @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException &#123; return null; &#125; @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException &#123; return null; &#125; @Override public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException &#123; return false; &#125;&#125; 第七步：定义GodMappedStatement123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package org.god.core;/** * SQL映射实体类 * @author 老杜 * @version 1.0 * @since 1.0 */public class GodMappedStatement &#123; private String sqlId; private String resultType; private String sql; private String parameterType; private String sqlType; @Override public String toString() &#123; return &quot;GodMappedStatement&#123;&quot; + &quot;sqlId=&#x27;&quot; + sqlId + &#x27;\\&#x27;&#x27; + &quot;, resultType=&#x27;&quot; + resultType + &#x27;\\&#x27;&#x27; + &quot;, sql=&#x27;&quot; + sql + &#x27;\\&#x27;&#x27; + &quot;, parameterType=&#x27;&quot; + parameterType + &#x27;\\&#x27;&#x27; + &quot;, sqlType=&#x27;&quot; + sqlType + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getSqlId() &#123; return sqlId; &#125; public void setSqlId(String sqlId) &#123; this.sqlId = sqlId; &#125; public String getResultType() &#123; return resultType; &#125; public void setResultType(String resultType) &#123; this.resultType = resultType; &#125; public String getSql() &#123; return sql; &#125; public void setSql(String sql) &#123; this.sql = sql; &#125; public String getParameterType() &#123; return parameterType; &#125; public void setParameterType(String parameterType) &#123; this.parameterType = parameterType; &#125; public String getSqlType() &#123; return sqlType; &#125; public void setSqlType(String sqlType) &#123; this.sqlType = sqlType; &#125; public GodMappedStatement(String sqlId, String resultType, String sql, String parameterType, String sqlType) &#123; this.sqlId = sqlId; this.resultType = resultType; this.sql = sql; this.parameterType = parameterType; this.sqlType = sqlType; &#125;&#125; 第八步：完善SqlSessionFactory类12345678910111213141516171819202122232425262728293031323334353637package org.god.core;import javax.sql.DataSource;import java.util.List;import java.util.Map;/** * SqlSession工厂对象，使用SqlSessionFactory可以获取会话对象 * @author 老杜 * @version 1.0 * @since 1.0 */public class SqlSessionFactory &#123; private TransactionManager transactionManager; private Map&lt;String, GodMappedStatement&gt; mappedStatements; public SqlSessionFactory(TransactionManager transactionManager, Map&lt;String, GodMappedStatement&gt; mappedStatements) &#123; this.transactionManager = transactionManager; this.mappedStatements = mappedStatements; &#125; public TransactionManager getTransactionManager() &#123; return transactionManager; &#125; public void setTransactionManager(TransactionManager transactionManager) &#123; this.transactionManager = transactionManager; &#125; public Map&lt;String, GodMappedStatement&gt; getMappedStatements() &#123; return mappedStatements; &#125; public void setMappedStatements(Map&lt;String, GodMappedStatement&gt; mappedStatements) &#123; this.mappedStatements = mappedStatements; &#125;&#125; 第九步：完善SqlSessionFactoryBuilder中的build方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package org.god.core;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import javax.sql.DataSource;import java.io.InputStream;import java.util.HashMap;import java.util.Map;/** * SqlSessionFactory对象构建器 * * @author 老杜 * @version 1.0 * @since 1.0 */public class SqlSessionFactoryBuilder &#123; /** * 创建构建器对象 */ public SqlSessionFactoryBuilder() &#123; &#125; /** * 获取SqlSessionFactory对象 * 该方法主要功能是：读取godbatis核心配置文件，并构建SqlSessionFactory对象 * * @param inputStream 指向核心配置文件的输入流 * @return SqlSessionFactory对象 */ public SqlSessionFactory build(InputStream inputStream) throws DocumentException &#123; SAXReader saxReader = new SAXReader(); Document document = saxReader.read(inputStream); Element environmentsElt = (Element) document.selectSingleNode(&quot;/configuration/environments&quot;); String defaultEnv = environmentsElt.attributeValue(&quot;default&quot;); Element environmentElt = (Element) document.selectSingleNode(&quot;/configuration/environments/environment[@id=&#x27;&quot; + defaultEnv + &quot;&#x27;]&quot;); // 解析配置文件，创建数据源对象 Element dataSourceElt = environmentElt.element(&quot;dataSource&quot;); DataSource dataSource = getDataSource(dataSourceElt); // 解析配置文件，创建事务管理器对象 Element transactionManagerElt = environmentElt.element(&quot;transactionManager&quot;); TransactionManager transactionManager = getTransactionManager(transactionManagerElt, dataSource); // 解析配置文件，获取所有的SQL映射对象 Element mappers = environmentsElt.element(&quot;mappers&quot;); Map&lt;String, GodMappedStatement&gt; mappedStatements = getMappedStatements(mappers); // 将以上信息封装到SqlSessionFactory对象中 SqlSessionFactory sqlSessionFactory = new SqlSessionFactory(transactionManager, mappedStatements); // 返回 return sqlSessionFactory; &#125; private Map&lt;String, GodMappedStatement&gt; getMappedStatements(Element mappers) &#123; Map&lt;String, GodMappedStatement&gt; mappedStatements = new HashMap&lt;&gt;(); mappers.elements().forEach(mapperElt -&gt; &#123; try &#123; String resource = mapperElt.attributeValue(&quot;resource&quot;); SAXReader saxReader = new SAXReader(); Document document = saxReader.read(Resources.getResourcesAsStream(resource)); Element mapper = (Element) document.selectSingleNode(&quot;/mapper&quot;); String namespace = mapper.attributeValue(&quot;namespace&quot;); mapper.elements().forEach(sqlMapper -&gt; &#123; String sqlId = sqlMapper.attributeValue(&quot;id&quot;); String sql = sqlMapper.getTextTrim(); String parameterType = sqlMapper.attributeValue(&quot;parameterType&quot;); String resultType = sqlMapper.attributeValue(&quot;resultType&quot;); String sqlType = sqlMapper.getName().toLowerCase(); // 封装GodMappedStatement对象 GodMappedStatement godMappedStatement = new GodMappedStatement(sqlId, resultType, sql, parameterType, sqlType); mappedStatements.put(namespace + &quot;.&quot; + sqlId, godMappedStatement); &#125;); &#125; catch (DocumentException e) &#123; throw new RuntimeException(e); &#125; &#125;); return mappedStatements; &#125; private TransactionManager getTransactionManager(Element transactionManagerElt, DataSource dataSource) &#123; String type = transactionManagerElt.attributeValue(&quot;type&quot;).toUpperCase(); TransactionManager transactionManager = null; if (&quot;JDBC&quot;.equals(type)) &#123; // 使用JDBC事务 transactionManager = new GodJDBCTransaction(dataSource, false); &#125; else if (&quot;MANAGED&quot;.equals(type)) &#123; // 事务管理器是交给JEE容器的 &#125; return transactionManager; &#125; private DataSource getDataSource(Element dataSourceElt) &#123; // 获取所有数据源的属性配置 Map&lt;String, String&gt; dataSourceMap = new HashMap&lt;&gt;(); dataSourceElt.elements().forEach(propertyElt -&gt; &#123; dataSourceMap.put(propertyElt.attributeValue(&quot;name&quot;), propertyElt.attributeValue(&quot;value&quot;)); &#125;); String dataSourceType = dataSourceElt.attributeValue(&quot;type&quot;).toUpperCase(); DataSource dataSource = null; if (&quot;POOLED&quot;.equals(dataSourceType)) &#123; &#125; else if (&quot;UNPOOLED&quot;.equals(dataSourceType)) &#123; dataSource = new GodUNPOOLEDDataSource(dataSourceMap.get(&quot;driver&quot;), dataSourceMap.get(&quot;url&quot;), dataSourceMap.get(&quot;username&quot;), dataSourceMap.get(&quot;password&quot;)); &#125; else if (&quot;JNDI&quot;.equals(dataSourceType)) &#123; &#125; return dataSource; &#125;&#125; 第十步：在SqlSessionFactory中添加openSession方法12345public SqlSession openSession()&#123; transactionManager.openConnection(); SqlSession sqlSession = new SqlSession(transactionManager, mappedStatements); return sqlSession;&#125; 第十一步：编写SqlSession类中commit rollback close方法1234567891011121314151617181920212223242526272829303132333435363738394041424344package org.god.core;import java.sql.SQLException;import java.util.Map;/** * 数据库会话对象 * @author 老杜 * @version 1.0 * @since 1.0 */public class SqlSession &#123; private TransactionManager transactionManager; private Map&lt;String, GodMappedStatement&gt; mappedStatements; public SqlSession(TransactionManager transactionManager, Map&lt;String, GodMappedStatement&gt; mappedStatements) &#123; this.transactionManager = transactionManager; this.mappedStatements = mappedStatements; &#125; public void commit()&#123; try &#123; transactionManager.getConnection().commit(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void rollback()&#123; try &#123; transactionManager.getConnection().rollback(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void close()&#123; try &#123; transactionManager.getConnection().close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 第十二步：编写SqlSession类中的insert方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 插入数据 * * @param sqlId 要执行的sqlId * @param obj 插入的数据 * @return */public int insert(String sqlId, Object obj) &#123; GodMappedStatement godMappedStatement = mappedStatements.get(sqlId); Connection connection = transactionManager.getConnection(); // 获取sql语句 // insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;) String godbatisSql = godMappedStatement.getSql(); // insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,?,?,?,?,?) String sql = godbatisSql.replaceAll(&quot;#\\\\&#123;[a-zA-Z0-9_\\\\$]*&#125;&quot;, &quot;?&quot;); // 重点一步 Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); int index = 1; while (godbatisSql.indexOf(&quot;#&quot;) &gt;= 0) &#123; int beginIndex = godbatisSql.indexOf(&quot;#&quot;) + 2; int endIndex = godbatisSql.indexOf(&quot;&#125;&quot;); map.put(index++, godbatisSql.substring(beginIndex, endIndex).trim()); godbatisSql = godbatisSql.substring(endIndex + 1); &#125; final PreparedStatement ps; try &#123; ps = connection.prepareStatement(sql); // 给?赋值 map.forEach((k, v) -&gt; &#123; try &#123; // 获取java实体类的get方法名 String getMethodName = &quot;get&quot; + v.toUpperCase().charAt(0) + v.substring(1); Method getMethod = obj.getClass().getDeclaredMethod(getMethodName); ps.setString(k, getMethod.invoke(obj).toString()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;); int count = ps.executeUpdate(); ps.close(); return count; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125; 第十三步：编写SqlSession类中的selectOne方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 查询一个对象 * @param sqlId * @param parameterObj * @return */public Object selectOne(String sqlId, Object parameterObj)&#123; GodMappedStatement godMappedStatement = mappedStatements.get(sqlId); Connection connection = transactionManager.getConnection(); // 获取sql语句 String godbatisSql = godMappedStatement.getSql(); String sql = godbatisSql.replaceAll(&quot;#\\\\&#123;[a-zA-Z0-9_\\\\$]*&#125;&quot;, &quot;?&quot;); // 执行sql PreparedStatement ps = null; ResultSet rs = null; Object obj = null; try &#123; ps = connection.prepareStatement(sql); ps.setString(1, parameterObj.toString()); rs = ps.executeQuery(); if (rs.next()) &#123; // 将结果集封装对象，通过反射 String resultType = godMappedStatement.getResultType(); Class&lt;?&gt; aClass = Class.forName(resultType); Constructor&lt;?&gt; con = aClass.getDeclaredConstructor(); obj = con.newInstance(); // 给对象obj属性赋值 ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); for (int i = 1; i &lt;= columnCount; i++) &#123; String columnName = rsmd.getColumnName(i); String setMethodName = &quot;set&quot; + columnName.toUpperCase().charAt(0) + columnName.substring(1); Method setMethod = aClass.getDeclaredMethod(setMethodName, aClass.getDeclaredField(columnName).getType()); setMethod.invoke(obj, rs.getString(columnName)); &#125; &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; try &#123; ps.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; return obj;&#125; 5.3 GodBatis使用Maven打包 查看本地仓库中是否已经有jar包： 5.4 使用GodBatis使用GodBatis就和使用MyBatis是一样的。 第一步：准备数据库表t_user 第二步：创建模块，普通的Java Maven模块：godbatis-test 第三步：引入依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.powernode&lt;/groupId&gt; &lt;artifactId&gt;godbatis-test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!--godbatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.god&lt;/groupId&gt; &lt;artifactId&gt;godbatis&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;/project&gt; 第四步：编写pojo类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.powernode.godbatis.pojo;public class User &#123; private String id; private String name; private String email; private String address; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public User() &#123; &#125; public User(String id, String name, String email, String address) &#123; this.id = id; this.name = name; this.email = email; this.address = address; &#125;&#125; 第五步：编写核心配置文件：godbatis-config.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;UNPOOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;mappers&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/environments&gt;&lt;/configuration&gt; 第六步：编写sql映射文件：UserMapper.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;mapper namespace=&quot;user&quot;&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user(id,name,email,address) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;address&#125;) &lt;/insert&gt; &lt;select id=&quot;selectUserById&quot; resultType=&quot;com.powernode.godbatis.pojo.User&quot;&gt; select * from t_user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 第七步：编写测试类 123456789101112131415161718192021222324252627282930313233package com.powernode.godbatis.test;import com.powernode.godbatis.pojo.User;import org.god.core.Resources;import org.god.core.SqlSession;import org.god.core.SqlSessionFactory;import org.god.core.SqlSessionFactoryBuilder;import org.junit.Test;public class GodBatisTest &#123; @Test public void testInsertUser() throws Exception&#123; User user = new User(&quot;1&quot;, &quot;zhangsan&quot;, &quot;zhangsan@1234.com&quot;, &quot;北京大兴区&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourcesAsStream(&quot;godbatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); int count = sqlSession.insert(&quot;user.insertUser&quot;, user); System.out.println(&quot;插入了几条记录：&quot; + count); sqlSession.commit(); sqlSession.close(); &#125; @Test public void testSelectUserById() throws Exception&#123; SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourcesAsStream(&quot;godbatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); Object user = sqlSession.selectOne(&quot;user.selectUserById&quot;, &quot;1&quot;); System.out.println(user); sqlSession.close(); &#125;&#125; 第八步：运行结果 5.5 总结MyBatis框架的重要实现原理12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;mapper namespace=&quot;user&quot;&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user(id,name,email,address) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;address&#125;) &lt;/insert&gt; &lt;select id=&quot;selectUserById&quot; resultType=&quot;com.powernode.godbatis.pojo.User&quot;&gt; select id,name,email,address from t_user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 思考两个问题： 为什么insert语句中 #{} 里填写的必须是属性名？ 为什么select语句查询结果列名要属性名一致？ 六、在WEB中应用MyBatis（使用MVC架构模式）目标： 掌握mybatis在web应用中怎么用 mybatis三大对象的作用域和生命周期 ThreadLocal原理及使用 巩固MVC架构模式 为学习MyBatis的接口代理机制做准备 实现功能： 银行账户转账 使用技术： HTML + Servlet + MyBatis WEB应用的名称： bank 6.1 需求描述 6.2 数据库表的设计和准备数据 6.3 实现步骤第一步：环境搭建 IDEA中创建Maven WEB应用（mybatis-004-web） IDEA配置Tomcat，这里Tomcat使用10+版本。并部署应用到tomcat。 默认创建的maven web应用没有java和resources目录，包括两种解决方案 第一种：自己手动加上。 第二种：修改maven-archetype-webapp-1.4.jar中的配置文件 web.xml文件的版本较低，可以从tomcat10的样例文件中复制，然后修改 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot; metadata-complete=&quot;false&quot;&gt;&lt;/web-app&gt; 删除index.jsp文件，因为我们这个项目不使用JSP。只使用html。 确定pom.xml文件中的打包方式是war包。 引入相关依赖 编译器版本修改为17 引入的依赖包括：mybatis，mysql驱动，junit，logback，servlet。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.powernode&lt;/groupId&gt; &lt;artifactId&gt;mybatis-004-web&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;mybatis-004-web&lt;/name&gt; &lt;url&gt;http://localhost:8080/bank&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--logback依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;mybatis-004-web&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 引入相关配置文件，放到resources目录下（全部放到类的根路径下） mybatis-config.xml AccountMapper.xml logback.xml jdbc.properties 123456789101112131415161718192021222324252627282930313233343536jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/powernodejdbc.username=rootjdbc.password=root&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--一定要注意这里的路径哦！！！--&gt; &lt;mapper resource=&quot;AccountMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;account&quot;&gt;&lt;/mapper&gt; 第二步：前端页面index.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;银行账户转账&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--/bank是应用的根，部署web应用到tomcat的时候一定要注意这个名字--&gt;&lt;form action=&quot;/bank/transfer&quot; method=&quot;post&quot;&gt; 转出账户：&lt;input type=&quot;text&quot; name=&quot;fromActno&quot;/&gt;&lt;br&gt; 转入账户：&lt;input type=&quot;text&quot; name=&quot;toActno&quot;/&gt;&lt;br&gt; 转账金额：&lt;input type=&quot;text&quot; name=&quot;money&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;转账&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 第三步：创建pojo包、service包、dao包、web包、utils包 com.powernode.bank.pojo com.powernode.bank.service com.powernode.bank.service.impl com.powernode.bank.dao com.powernode.bank.dao.impl com.powernode.bank.web.controller com.powernode.bank.exception com.powernode.bank.utils：将之前编写的SqlSessionUtil工具类拷贝到该包下。 第四步：定义pojo类：Account12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.powernode.bank.pojo;/** * 银行账户类 * @author 老杜 * @version 1.0 * @since 1.0 */public class Account &#123; private Long id; private String actno; private Double balance; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;id=&quot; + id + &quot;, actno=&#x27;&quot; + actno + &#x27;\\&#x27;&#x27; + &quot;, balance=&quot; + balance + &#x27;&#125;&#x27;; &#125; public Account() &#123; &#125; public Account(Long id, String actno, Double balance) &#123; this.id = id; this.actno = actno; this.balance = balance; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getActno() &#123; return actno; &#125; public void setActno(String actno) &#123; this.actno = actno; &#125; public Double getBalance() &#123; return balance; &#125; public void setBalance(Double balance) &#123; this.balance = balance; &#125;&#125; 第五步：编写AccountDao接口，以及AccountDaoImpl实现类分析dao中至少要提供几个方法，才能完成转账： 转账前需要查询余额是否充足：selectByActno 转账时要更新账户：update 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.powernode.bank.dao;import com.powernode.bank.pojo.Account;/** * 账户数据访问对象 * @author 老杜 * @version 1.0 * @since 1.0 */public interface AccountDao &#123; /** * 根据账号获取账户信息 * @param actno 账号 * @return 账户信息 */ Account selectByActno(String actno); /** * 更新账户信息 * @param act 账户信息 * @return 1表示更新成功，其他值表示失败 */ int update(Account act);&#125;package com.powernode.bank.dao.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.pojo.Account;import com.powernode.bank.utils.SqlSessionUtil;import org.apache.ibatis.session.SqlSession;public class AccountDaoImpl implements AccountDao &#123; @Override public Account selectByActno(String actno) &#123; SqlSession sqlSession = SqlSessionUtil.openSession(); Account act = (Account)sqlSession.selectOne(&quot;selectByActno&quot;, actno); sqlSession.close(); return act; &#125; @Override public int update(Account act) &#123; SqlSession sqlSession = SqlSessionUtil.openSession(); int count = sqlSession.update(&quot;update&quot;, act); sqlSession.commit(); sqlSession.close(); return count; &#125;&#125; 第六步：AccountDaoImpl中编写了mybatis代码，需要编写SQL映射文件了12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;account&quot;&gt; &lt;select id=&quot;selectByActno&quot; resultType=&quot;com.powernode.bank.pojo.Account&quot;&gt; select * from t_act where actno = #&#123;actno&#125; &lt;/select&gt; &lt;update id=&quot;update&quot;&gt; update t_act set balance = #&#123;balance&#125; where actno = #&#123;actno&#125; &lt;/update&gt;&lt;/mapper&gt; 第七步：编写AccountService接口以及AccountServiceImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.powernode.bank.exception;/** * 余额不足异常 * @author 老杜 * @version 1.0 * @since 1.0 */public class MoneyNotEnoughException extends Exception&#123; public MoneyNotEnoughException()&#123;&#125; public MoneyNotEnoughException(String msg)&#123; super(msg); &#125;&#125;package com.powernode.bank.exception;/** * 应用异常 * @author 老杜 * @version 1.0 * @since 1.0 */public class AppException extends Exception&#123; public AppException()&#123;&#125; public AppException(String msg)&#123; super(msg); &#125;&#125;package com.powernode.bank.service;import com.powernode.bank.exception.AppException;import com.powernode.bank.exception.MoneyNotEnoughException;/** * 账户业务类。 * @author 老杜 * @version 1.0 * @since 1.0 */public interface AccountService &#123; /** * 银行账户转正 * @param fromActno 转出账户 * @param toActno 转入账户 * @param money 转账金额 * @throws MoneyNotEnoughException 余额不足异常 * @throws AppException App发生异常 */ void transfer(String fromActno, String toActno, double money) throws MoneyNotEnoughException, AppException;&#125;package com.powernode.bank.service.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.dao.impl.AccountDaoImpl;import com.powernode.bank.exception.AppException;import com.powernode.bank.exception.MoneyNotEnoughException;SSimport com.powernode.bank.pojo.Account;import com.powernode.bank.service.AccountService;public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao = new AccountDaoImpl(); @Override public void transfer(String fromActno, String toActno, double money) throws MoneyNotEnoughException, AppException &#123; // 查询转出账户的余额 Account fromAct = accountDao.selectByActno(fromActno); if (fromAct.getBalance() &lt; money) &#123; throw new MoneyNotEnoughException(&quot;对不起，您的余额不足。&quot;); &#125; try &#123; // 程序如果执行到这里说明余额充足 // 修改账户余额 Account toAct = accountDao.selectByActno(toActno); fromAct.setBalance(fromAct.getBalance() - money); toAct.setBalance(toAct.getBalance() + money); // 更新数据库 accountDao.update(fromAct); accountDao.update(toAct); &#125; catch (Exception e) &#123; throw new AppException(&quot;转账失败，未知原因！&quot;); &#125; &#125;&#125; 第八步：编写AccountController12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.powernode.bank.web.controller;import com.powernode.bank.exception.AppException;import com.powernode.bank.exception.MoneyNotEnoughException;import com.powernode.bank.service.AccountService;import com.powernode.bank.service.impl.AccountServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * 账户控制器 * @author 老杜 * @version 1.0 * @since 1.0 */@WebServlet(&quot;/transfer&quot;)public class AccountController extends HttpServlet &#123; private AccountService accountService = new AccountServiceImpl(); @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取响应流 response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); // 获取账户信息 String fromActno = request.getParameter(&quot;fromActno&quot;); String toActno = request.getParameter(&quot;toActno&quot;); double money = Integer.parseInt(request.getParameter(&quot;money&quot;)); // 调用业务方法完成转账 try &#123; accountService.transfer(fromActno, toActno, money); out.print(&quot;&lt;h1&gt;转账成功！！！&lt;/h1&gt;&quot;); &#125; catch (MoneyNotEnoughException e) &#123; out.print(e.getMessage()); &#125; catch (AppException e) &#123; out.print(e.getMessage()); &#125; &#125;&#125; 启动服务器，打开浏览器，输入地址：http://localhost:8080/bank，测试： 6.4 MyBatis对象作用域以及事务问题MyBatis核心对象的作用域SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式： 123try (SqlSession session = sqlSessionFactory.openSession()) &#123; // 你的应用逻辑代码&#125; 事务问题在之前的转账业务中，更新了两个账户，我们需要保证它们的同时成功或同时失败，这个时候就需要使用事务机制，在transfer方法开始执行时开启事务，直到两个更新都成功之后，再提交事务，我们尝试将transfer方法进行如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.powernode.bank.service.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.dao.impl.AccountDaoImpl;import com.powernode.bank.exception.AppException;import com.powernode.bank.exception.MoneyNotEnoughException;import com.powernode.bank.pojo.Account;import com.powernode.bank.service.AccountService;import com.powernode.bank.utils.SqlSessionUtil;import org.apache.ibatis.session.SqlSession;public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao = new AccountDaoImpl(); @Override public void transfer(String fromActno, String toActno, double money) throws MoneyNotEnoughException, AppException &#123; // 查询转出账户的余额 Account fromAct = accountDao.selectByActno(fromActno); if (fromAct.getBalance() &lt; money) &#123; throw new MoneyNotEnoughException(&quot;对不起，您的余额不足。&quot;); &#125; try &#123; // 程序如果执行到这里说明余额充足 // 修改账户余额 Account toAct = accountDao.selectByActno(toActno); fromAct.setBalance(fromAct.getBalance() - money); toAct.setBalance(toAct.getBalance() + money); // 更新数据库（添加事务） SqlSession sqlSession = SqlSessionUtil.openSession(); accountDao.update(fromAct); // 模拟异常 String s = null; s.toString(); accountDao.update(toAct); sqlSession.commit(); sqlSession.close(); &#125; catch (Exception e) &#123; throw new AppException(&quot;转账失败，未知原因！&quot;); &#125; &#125;&#125; 运行前注意看数据库表中当前的数据： 执行程序： 再次查看数据库表中的数据： 傻眼了吧！！！事务出问题了，转账失败了，钱仍然是少了1万。这是什么原因呢？主要是因为service和dao中使用的SqlSession对象不是同一个。 怎么办？为了保证service和dao中使用的SqlSession对象是同一个，可以将SqlSession对象存放到ThreadLocal当中。修改SqlSessionUtil工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.powernode.bank.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;/** * MyBatis工具类 * * @author 老杜 * @version 1.0 * @since 1.0 */public class SqlSessionUtil &#123; private static SqlSessionFactory sqlSessionFactory; /** * 类加载时初始化sqlSessionFactory对象 */ static &#123; try &#123; SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static ThreadLocal&lt;SqlSession&gt; local = new ThreadLocal&lt;&gt;(); /** * 每调用一次openSession()可获取一个新的会话，该会话支持自动提交。 * * @return 新的会话对象 */ public static SqlSession openSession() &#123; SqlSession sqlSession = local.get(); if (sqlSession == null) &#123; sqlSession = sqlSessionFactory.openSession(); local.set(sqlSession); &#125; return sqlSession; &#125; /** * 关闭SqlSession对象 * @param sqlSession */ public static void close(SqlSession sqlSession)&#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; local.remove(); &#125;&#125; 修改dao中的方法：AccountDaoImpl中所有方法中的提交commit和关闭close代码全部删除。 12345678910111213141516171819202122package com.powernode.bank.dao.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.pojo.Account;import com.powernode.bank.utils.SqlSessionUtil;import org.apache.ibatis.session.SqlSession;public class AccountDaoImpl implements AccountDao &#123; @Override public Account selectByActno(String actno) &#123; SqlSession sqlSession = SqlSessionUtil.openSession(); Account act = (Account)sqlSession.selectOne(&quot;account.selectByActno&quot;, actno); return act; &#125; @Override public int update(Account act) &#123; SqlSession sqlSession = SqlSessionUtil.openSession(); int count = sqlSession.update(&quot;account.update&quot;, act); return count; &#125;&#125; 修改service中的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.powernode.bank.service.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.dao.impl.AccountDaoImpl;import com.powernode.bank.exception.AppException;import com.powernode.bank.exception.MoneyNotEnoughException;import com.powernode.bank.pojo.Account;import com.powernode.bank.service.AccountService;import com.powernode.bank.utils.SqlSessionUtil;import org.apache.ibatis.session.SqlSession;public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao = new AccountDaoImpl(); @Override public void transfer(String fromActno, String toActno, double money) throws MoneyNotEnoughException, AppException &#123; // 查询转出账户的余额 Account fromAct = accountDao.selectByActno(fromActno); if (fromAct.getBalance() &lt; money) &#123; throw new MoneyNotEnoughException(&quot;对不起，您的余额不足。&quot;); &#125; try &#123; // 程序如果执行到这里说明余额充足 // 修改账户余额 Account toAct = accountDao.selectByActno(toActno); fromAct.setBalance(fromAct.getBalance() - money); toAct.setBalance(toAct.getBalance() + money); // 更新数据库（添加事务） SqlSession sqlSession = SqlSessionUtil.openSession(); accountDao.update(fromAct); // 模拟异常 String s = null; s.toString(); accountDao.update(toAct); sqlSession.commit(); SqlSessionUtil.close(sqlSession); // 只修改了这一行代码。 &#125; catch (Exception e) &#123; throw new AppException(&quot;转账失败，未知原因！&quot;); &#125; &#125;&#125; 当前数据库表中的数据： 再次运行程序： 查看数据库表：没有问题。 再测试转账成功： 如果余额不足呢： 账户的余额依然正常： 6.5 分析当前程序存在的问题我们来看一下DaoImpl的代码 12345678910111213141516171819202122package com.powernode.bank.dao.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.pojo.Account;import com.powernode.bank.utils.SqlSessionUtil;import org.apache.ibatis.session.SqlSession;public class AccountDaoImpl implements AccountDao &#123; @Override public Account selectByActno(String actno) &#123; SqlSession sqlSession = SqlSessionUtil.openSession(); Account act = (Account)sqlSession.selectOne(&quot;account.selectByActno&quot;, actno); return act; &#125; @Override public int update(Account act) &#123; SqlSession sqlSession = SqlSessionUtil.openSession(); int count = sqlSession.update(&quot;account.update&quot;, act); return count; &#125;&#125; 我们不难发现，这个dao实现类中的方法代码很固定，基本上就是一行代码，通过SqlSession对象调用insert、delete、update、select等方法，这个类中的方法没有任何业务逻辑，既然是这样，这个类我们能不能动态的生成，以后可以不写这个类吗？答案：可以。 七、使用javassist生成类来自百度百科： Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态”AOP”框架。 简单介绍: Javassist是一个开源的分析、编辑和创建Java字节码的类库。 关于java字节码的处理，目前有很多工具，如bcel，asm。不过这些都需要直接跟虚拟机指令打交道。如果你不想了解虚拟机指令，可以采用javassist。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。简而言之：Javassist 能够转换现有类的基本内容，或创建一个新类。 Javassist 可以检查、编辑以及创建 Java 二进制类。检查方面基本上与通过 Reflection API 直接在 Java 中进行的一样。Javassist 使用类池 javassist.ClassPool 类跟踪和控制所操作的类。其工作方式与 JVM 类装载器非常相似，但是有一个重要的区别是它不是将装载的、要执行的类作为应用程序的一部分链接，类池使所装载的类可以通过 Javassist API 作为数据使用。可以使用默认的类池，它是从 JVM 搜索路径中装载的，也可以定义一个搜索自定义路径列表的类池。甚至可以直接从字节数组或者流中装载二进制类，以及从头开始创建新类。 装载到类池中的类由 javassist.CtClass 实例表示。与标准的 Java java.lang.Class 类一样， CtClass 提供了检查类数据（如字段和方法）的方法。不过，这只是 CtClass 的部分内容，它还定义了在类中添加新字段、方法和构造函数、以及改变类、父类和接口的方法。奇怪的是，Javassist 没有提供删除一个类中字段、方法或者构造函数的任何方法。 字段、方法和构造函数分别由 javassist.CtField、javassist.CtMethod 和 javassist.CtConstructor 的实例表示。这些类定义了修改由它们所表示的对象的所有方法的方法，包括方法或者构造函数中的实际字节码内容。 总结：反射可以使用字节码文件里面的信息，javassist 可以根据字节码信息动态的生成自己所需要的类 7.1 Javassist的使用我们要使用javassist，首先要引入它的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.29.1-GA&lt;/version&gt;&lt;/dependency&gt; 样例代码： 12345678910111213141516171819202122232425262728293031package com.powernode.javassist;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import javassist.Modifier;import java.lang.reflect.Method;public class JavassistTest &#123; public static void main(String[] args) throws Exception &#123; // 获取类池 ClassPool pool = ClassPool.getDefault(); // 创建类 CtClass ctClass = pool.makeClass(&quot;com.powernode.javassist.Test&quot;); // 创建方法 // 1.返回值类型 2.方法名 3.形式参数列表 4.所属类 CtMethod ctMethod = new CtMethod(CtClass.voidType, &quot;execute&quot;, new CtClass[]&#123;&#125;, ctClass); // 设置方法的修饰符列表 ctMethod.setModifiers(Modifier.PUBLIC); // 设置方法体 ctMethod.setBody(&quot;&#123;System.out.println(\\&quot;hello world\\&quot;);&#125;&quot;); // 给类添加方法 ctClass.addMethod(ctMethod); // 调用方法 Class&lt;?&gt; aClass = ctClass.toClass(); Object o = aClass.newInstance(); Method method = aClass.getDeclaredMethod(&quot;execute&quot;); method.invoke(o); &#125;&#125; 运行要注意：加两个参数，要不然会有异常。 –add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED –add-opens java.base&#x2F;sun.net.util&#x3D;ALL-UNNAMED 运行结果： 7.2 使用Javassist生成DaoImpl类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.powernode.bank.utils;import org.apache.ibatis.javassist.ClassPool;import org.apache.ibatis.javassist.CtClass;import org.apache.ibatis.javassist.CtMethod;import org.apache.ibatis.mapping.SqlCommandType;import org.apache.ibatis.session.SqlSession;import java.lang.reflect.Method;import java.util.Arrays;/** * 工具类：可以动态的生成DAO的实现类。（或者说可以动态生成DAO的代理类） * 注意注意注意注意注意！！！！！！： * 凡是使用GenerateDaoProxy的，SQLMapper.xml映射文件中namespace必须是dao接口的全名，id必须是dao接口中的方法名。 * @author 动力节点 * @version 1.0 * @since 1.0 */public class GenerateDaoProxy &#123; // GenerateDaoProxy是mybatis框架的开发者写的。 /** * 生成dao接口实现类，并且将实现类的对象创建出来并返回。 * @param daoInterface dao接口 * @return dao接口实现类的实例化对象。 */ public static Object generate(SqlSession sqlSession, Class daoInterface)&#123; // 类池 ClassPool pool = ClassPool.getDefault(); // 制造类(com.powernode.bank.dao.AccountDao --&gt; com.powernode.bank.dao.AccountDaoProxy) CtClass ctClass = pool.makeClass(daoInterface.getName() + &quot;Proxy&quot;); // 实际本质上就是在内存中动态生成一个代理类。 // 制造接口 CtClass ctInterface = pool.makeInterface(daoInterface.getName()); // 实现接口 ctClass.addInterface(ctInterface); // 实现接口中所有的方法 Method[] methods = daoInterface.getDeclaredMethods(); Arrays.stream(methods).forEach(method -&gt; &#123; // method是接口中的抽象方法 // 将method这个抽象方法进行实现 try &#123; // Account selectByActno(String actno); // public Account selectByActno(String actno)&#123; 代码; &#125; StringBuilder methodCode = new StringBuilder(); methodCode.append(&quot;public &quot;); methodCode.append(method.getReturnType().getName()); methodCode.append(&quot; &quot;); methodCode.append(method.getName()); methodCode.append(&quot;(&quot;); // 需要方法的形式参数列表 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (int i = 0; i &lt; parameterTypes.length; i++) &#123; Class&lt;?&gt; parameterType = parameterTypes[i]; methodCode.append(parameterType.getName()); methodCode.append(&quot; &quot;); methodCode.append(&quot;arg&quot;).append(i); if(i != parameterTypes.length - 1)&#123; methodCode.append(&quot;,&quot;); &#125; &#125; methodCode.append(&quot;)&quot;); methodCode.append(&quot;&#123;&quot;); // 需要方法体当中的代码 methodCode.append(&quot;org.apache.ibatis.session.SqlSession sqlSession = com.powernode.bank.utils.SqlSessionUtil.openSession();&quot;); // 需要知道是什么类型的sql语句 // sql语句的id是框架使用者提供的，具有多变性。对于我框架的开发人员来说。我不知道。 // 既然我框架开发者不知道sqlId，怎么办呢？mybatis框架的开发者于是就出台了一个规定：凡是使用GenerateDaoProxy机制的。 // sqlId都不能随便写。namespace必须是dao接口的全限定名称。id必须是dao接口中方法名。 String sqlId = daoInterface.getName() + &quot;.&quot; + method.getName(); System.out.println( &quot;sqlId======================&quot; + sqlId); SqlCommandType sqlCommandType = sqlSession.getConfiguration().getMappedStatement(sqlId).getSqlCommandType(); if (sqlCommandType == SqlCommandType.INSERT) &#123; &#125; if (sqlCommandType == SqlCommandType.DELETE) &#123; &#125; if (sqlCommandType == SqlCommandType.UPDATE) &#123; methodCode.append(&quot;return sqlSession.update(\\&quot;&quot;+sqlId+&quot;\\&quot;, arg0);&quot;); &#125; if (sqlCommandType == SqlCommandType.SELECT) &#123; String returnType = method.getReturnType().getName(); methodCode.append(&quot;return (&quot;+returnType+&quot;)sqlSession.selectOne(\\&quot;&quot;+sqlId+&quot;\\&quot;, arg0);&quot;); &#125; methodCode.append(&quot;&#125;&quot;); CtMethod ctMethod = CtMethod.make(methodCode.toString(), ctClass); ctClass.addMethod(ctMethod); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); // 创建对象 Object obj = null; try &#123; Class&lt;?&gt; clazz = ctClass.toClass(); obj = clazz.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 使用Javassist动态生成DaoImpl类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.powernode.bank.utils;import org.apache.ibatis.javassist.CannotCompileException;import org.apache.ibatis.javassist.ClassPool;import org.apache.ibatis.javassist.CtClass;import org.apache.ibatis.javassist.CtMethod;import org.apache.ibatis.session.SqlSession;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.Arrays;/** * 使用javassist库动态生成dao接口的实现类 * * @author 老杜 * @version 1.0 * @since 1.0 */public class GenerateDaoByJavassist &#123; /** * 根据dao接口生成dao接口的代理对象 * * @param sqlSession sql会话 * @param daoInterface dao接口 * @return dao接口代理对象 */ public static Object getMapper(SqlSession sqlSession, Class daoInterface) &#123; ClassPool pool = ClassPool.getDefault(); // 生成代理类 CtClass ctClass = pool.makeClass(daoInterface.getPackageName() + &quot;.impl.&quot; + daoInterface.getSimpleName() + &quot;Impl&quot;); // 接口 CtClass ctInterface = pool.makeClass(daoInterface.getName()); // 代理类实现接口 ctClass.addInterface(ctInterface); // 获取所有的方法 Method[] methods = daoInterface.getDeclaredMethods(); Arrays.stream(methods).forEach(method -&gt; &#123; // 拼接方法的签名 StringBuilder methodStr = new StringBuilder(); String returnTypeName = method.getReturnType().getName(); methodStr.append(returnTypeName); methodStr.append(&quot; &quot;); String methodName = method.getName(); methodStr.append(methodName); methodStr.append(&quot;(&quot;); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (int i = 0; i &lt; parameterTypes.length; i++) &#123; methodStr.append(parameterTypes[i].getName()); methodStr.append(&quot; arg&quot;); methodStr.append(i); if (i != parameterTypes.length - 1) &#123; methodStr.append(&quot;,&quot;); &#125; &#125; methodStr.append(&quot;)&#123;&quot;); // 方法体当中的代码怎么写？ // 获取sqlId（这里非常重要：因为这行代码导致以后namespace必须是接口的全限定接口名，sqlId必须是接口中方法的方法名。） String sqlId = daoInterface.getName() + &quot;.&quot; + methodName; // 获取SqlCommondType String sqlCommondTypeName = sqlSession.getConfiguration().getMappedStatement(sqlId).getSqlCommandType().name(); if (&quot;SELECT&quot;.equals(sqlCommondTypeName)) &#123; methodStr.append(&quot;org.apache.ibatis.session.SqlSession sqlSession = com.powernode.bank.utils.SqlSessionUtil.openSession();&quot;); methodStr.append(&quot;Object obj = sqlSession.selectOne(\\&quot;&quot; + sqlId + &quot;\\&quot;, arg0);&quot;); methodStr.append(&quot;return (&quot; + returnTypeName + &quot;)obj;&quot;); &#125; else if (&quot;UPDATE&quot;.equals(sqlCommondTypeName)) &#123; methodStr.append(&quot;org.apache.ibatis.session.SqlSession sqlSession = com.powernode.bank.utils.SqlSessionUtil.openSession();&quot;); methodStr.append(&quot;int count = sqlSession.update(\\&quot;&quot; + sqlId + &quot;\\&quot;, arg0);&quot;); methodStr.append(&quot;return count;&quot;); &#125; methodStr.append(&quot;&#125;&quot;); System.out.println(methodStr); try &#123; // 创建CtMethod对象 CtMethod ctMethod = CtMethod.make(methodStr.toString(), ctClass); ctMethod.setModifiers(Modifier.PUBLIC); // 将方法添加到类 ctClass.addMethod(ctMethod); &#125; catch (CannotCompileException e) &#123; throw new RuntimeException(e); &#125; &#125;); try &#123; // 创建代理对象 Class&lt;?&gt; aClass = ctClass.toClass(); Constructor&lt;?&gt; defaultCon = aClass.getDeclaredConstructor(); Object o = defaultCon.newInstance(); return o; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 修改AccountMapper.xml文件：namespace必须是dao接口的全限定名称，id必须是dao接口中的方法名： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.bank.dao.AccountDao&quot;&gt; &lt;select id=&quot;selectByActno&quot; resultType=&quot;com.powernode.bank.pojo.Account&quot;&gt; select * from t_act where actno = #&#123;actno&#125; &lt;/select&gt; &lt;update id=&quot;update&quot;&gt; update t_act set balance = #&#123;balance&#125; where actno = #&#123;actno&#125; &lt;/update&gt;&lt;/mapper&gt; 修改service类中获取dao对象的代码： 启动服务器：启动过程中显示，tomcat服务器自动添加了以下的两个运行参数。所以不需要再单独配置。 测试前数据： 打开浏览器测试： 八、MyBatis中接口代理机制及使用好消息！！！其实以上所讲内容mybatis内部已经实现了。直接调用以下代码即可获取dao接口的代理类： 1AccountDao accountDao = (AccountDao)sqlSession.getMapper(AccountDao.class); 使用以上代码的前提是：AccountMapper.xml文件中的namespace必须和dao接口的全限定名称一致，id必须和dao接口中方法名一致。 将service中获取dao对象的代码再次修改，如下： 测试前数据： 测试后数据： 九、MyBatis小技巧整体看这里123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116mybatis小技巧1. #&#123;&#125;和$&#123;&#125;的区别#&#123;&#125;的执行结果：[main] DEBUG c.p.mybatis.mapper.CarMapper.selectByCarType - ==&gt; Preparing: select id, car_num as carNum, brand, guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car where car_type = ?[main] DEBUG c.p.mybatis.mapper.CarMapper.selectByCarType - ==&gt; Parameters: 新能源(String)[main] DEBUG c.p.mybatis.mapper.CarMapper.selectByCarType - &lt;== Total: 2$&#123;&#125;的执行结果：[main] DEBUG c.p.mybatis.mapper.CarMapper.selectByCarType - ==&gt; Preparing: select id, car_num as carNum, brand, guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car where car_type = 新能源[main] DEBUG c.p.mybatis.mapper.CarMapper.selectByCarType - ==&gt; Parameters:org.apache.ibatis.exceptions.PersistenceException:### Error querying database. Cause: java.sql.SQLSyntaxErrorException: Unknown column &#x27;新能源&#x27; in &#x27;where clause&#x27;### The error may exist in CarMapper.xml### The error may involve defaultParameterMap### The error occurred while setting parameters### SQL: select id, car_num as carNum, brand, guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car where car_type = 新能源### Cause: java.sql.SQLSyntaxErrorException: Unknown column &#x27;新能源&#x27; in &#x27;where clause&#x27;#&#123;&#125;和$&#123;&#125;的区别： #&#123;&#125;: 底层使用PreparedStatement。特点：先进行SQL语句的编译，然后给SQL语句的占位符问号?传值。可以避免SQL注入的风险。 $&#123;&#125;：底层使用Statement。特点：先进行SQL语句的拼接，然后再对SQL语句进行编译。存在SQL注入的风险。 优先使用#&#123;&#125;，这是原则。避免SQL注入的风险。#&#123;&#125;的执行结果：Preparing: select id, car_num as carNum, brand, guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car order by produce_time ?Parameters: asc(String)select id, car_num as carNum, brand, guide_price as guidePrice, produce_time as produceTime, car_type as carTypefrom t_car order by produce_time &#x27;asc&#x27;$&#123;&#125;的执行结果：Preparing: select id, car_num as carNum, brand, guide_price as guidePrice, produce_time as produceTime, car_type as carType from t_car order by produce_time ascParameters:如果需要SQL语句的关键字放到SQL语句中，只能使用$&#123;&#125;，因为#&#123;&#125;是以值的形式放到SQL语句当中的。2. 向SQL语句当中拼接表名，就需要使用$&#123;&#125; 现实业务当中，可能会存在分表存储数据的情况。因为一张表存的话，数据量太大。查询效率比较低。 可以将这些数据有规律的分表存储，这样在查询的时候效率就比较高。因为扫描的数据量变少了。 日志表：专门存储日志信息的。如果t_log只有一张表，这张表中每一天都会产生很多log，慢慢的，这个表中数据会很多。 怎么解决问题？ 可以每天生成一个新表。每张表以当天日期作为名称，例如： t_log_20220901 t_log_20220902 .... 你想知道某一天的日志信息怎么办？ 假设今天是20220901，那么直接查：t_log_20220901的表即可。3.批量删除：一次删除多条记录。 批量删除的SQL语句有两种写法： 第一种or：delete from t_car where id=1 or id=2 or id=3; 第二种int：delete from t_car where id in(1,2,3); 应该采用$&#123;&#125;的方式： delete from t_car where id in($&#123;ids&#125;);4.模糊查询：like 需求：根据汽车品牌进行模糊查询 select * from t_car where brand like &#x27;%奔驰%&#x27;; select * from t_car where brand like &#x27;%比亚迪%&#x27;; 第一种方案： &#x27;%$&#123;brand&#125;%&#x27; 第二种方案：concat函数，这个是mysql数据库当中的一个函数，专门进行字符串拼接 concat(&#x27;%&#x27;,#&#123;brand&#125;,&#x27;%&#x27;) 第三种方案：比较鸡肋了。可以不算。 concat(&#x27;%&#x27;,&#x27;$&#123;brand&#125;&#x27;,&#x27;%&#x27;) 第四种方案： &quot;%&quot;#&#123;brand&#125;&quot;%&quot;5. 关于MyBatis中别名机制: &lt;typeAliases&gt; &lt;!--别名自己指定的--&gt; &lt;typeAlias type=&quot;com.powernode.mybatis.pojo.Car&quot; alias=&quot;aaa&quot;/&gt; &lt;typeAlias type=&quot;com.powernode.mybatis.pojo.Log&quot; alias=&quot;bbb&quot;/&gt; &lt;!--采用默认的别名机制--&gt; &lt;typeAlias type=&quot;com.powernode.mybatis.pojo.Car&quot;/&gt; &lt;typeAlias type=&quot;com.powernode.mybatis.pojo.Log&quot;/&gt; &lt;!--包下所有的类自动起别名。使用简名作为别名。--&gt; &lt;package name=&quot;com.powernode.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt; 所有别名不区分大小写。 namespace不能使用别名机制。6. mybatis-config.xml文件中的mappers标签。 &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; 要求类的根路径下必须有：CarMapper.xml &lt;mapper url=&quot;file:///d:/CarMapper.xml&quot;/&gt; 要求在d:/下有CarMapper.xml文件 &lt;mapper class=&quot;全限定接口名，带有包名&quot;/&gt; mapper标签的属性可以有三个： resource:这种方式是从类的根路径下开始查找资源。采用这种方式的话，你的配置文件需要放到类路径当中才行。 url: 这种方式是一种绝对路径的方式，这种方式不要求配置文件必须放到类路径当中，哪里都行，只要提供一个绝对路径就行。这种方式使用极少，因为移植性太差。 class: 这个位置提供的是mapper接口的全限定接口名，必须带有包名的。 思考：mapper标签的作用是指定SqlMapper.xml文件的路径，指定接口名有什么用呢？ &lt;mapper class=&quot;com.powernode.mybatis.mapper.CarMapper&quot;/&gt; 如果你class指定是：com.powernode.mybatis.mapper.CarMapper 那么mybatis框架会自动去com/powernode/mybatis/mapper目录下查找CarMapper.xml文件。 注意：也就是说：如果你采用这种方式，那么你必须保证CarMapper.xml文件和CarMapper接口必须在同一个目录下。并且名字一致。 CarMapper接口-&gt; CarMapper.xml LogMapper接口-&gt; LogMapper.xml .... 提醒！！！！！！！！！！！！！！！！！！！！！！！ 在IDEA的resources目录下新建多重目录的话，必须是这样创建： com/powernode/mybatis/mapper 不能这样： com.powernode.mybatis.mapper 9.1 #{}和${}#{}：先编译sql语句，再给占位符传值，底层是PreparedStatement实现。可以防止sql注入，比较常用。 ${}：先进行sql语句拼接，然后再编译sql语句，底层是Statement实现。存在sql注入现象。只有在需要进行sql语句关键字拼接的情况下才会用到。 需求：根据car_type查询汽车 模块名：mybatis-005-antic 使用#{}依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.powernode&lt;/groupId&gt; &lt;artifactId&gt;mybatis-005-antic&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!--mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--logback依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; jdbc.properties放在类的根路径下 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/powernodejdbc.username=rootjdbc.password=root logback.xml，可以拷贝之前的，放到类的根路径下 utils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.powernode.mybatis.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;/** * MyBatis工具类 * * @author 老杜 * @version 1.0 * @since 1.0 */public class SqlSessionUtil &#123; private static SqlSessionFactory sqlSessionFactory; /** * 类加载时初始化sqlSessionFactory对象 */ static &#123; try &#123; SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static ThreadLocal&lt;SqlSession&gt; local = new ThreadLocal&lt;&gt;(); /** * 每调用一次openSession()可获取一个新的会话，该会话支持自动提交。 * * @return 新的会话对象 */ public static SqlSession openSession() &#123; SqlSession sqlSession = local.get(); if (sqlSession == null) &#123; sqlSession = sqlSessionFactory.openSession(); local.set(sqlSession); &#125; return sqlSession; &#125; /** * 关闭SqlSession对象 * @param sqlSession */ public static void close(SqlSession sqlSession)&#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; local.remove(); &#125;&#125; pojo 123456789101112131415161718package com.powernode.mybatis.pojo;/** * 普通实体类：汽车 * @author 老杜 * @version 1.0 * @since 1.0 */public class Car &#123; private Long id; private String carNum; private String brand; private Double guidePrice; private String produceTime; private String carType; // 构造方法 // set get方法 // toString方法&#125; mapper接口 12345678910111213141516171819202122package com.powernode.mybatis.mapper;import com.powernode.mybatis.pojo.Car;import java.util.List;/** * Car的sql映射对象 * @author 老杜 * @version 1.0 * @since 1.0 */public interface CarMapper &#123; /** * 根据car_num获取Car * @param carType * @return */ List&lt;Car&gt; selectByCarType(String carType);&#125; mybatis-config.xml，放在类的根路径下 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; CarMapper.xml，放在类的根路径下：注意namespace必须和接口名一致。id必须和接口中方法名一致。 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.CarMapper&quot;&gt; &lt;select id=&quot;selectByCarType&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where car_type = #&#123;carType&#125; &lt;/select&gt;&lt;/mapper&gt; 测试程序 123456789101112131415161718192021222324package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.CarMapper;import com.powernode.mybatis.pojo.Car;import com.powernode.mybatis.utils.SqlSessionUtil;import org.junit.Test;import java.util.List;/** * CarMapper测试类 * @author 老杜 * @version 1.0 * @since 1.0 */public class CarMapperTest &#123; @Test public void testSelectByCarType()&#123; CarMapper mapper = (CarMapper) SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectByCarType(&quot;燃油车&quot;); cars.forEach(car -&gt; System.out.println(car)); &#125;&#125; 执行结果： 通过执行可以清楚的看到，sql语句中是带有 ? 的，这个 ? 就是大家在JDBC中所学的占位符，专门用来接收值的。 把“燃油车”以String类型的值，传递给 ? 这就是 #{}，它会先进行sql语句的预编译，然后再给占位符传值 使用${}同样的需求，我们使用${}来完成 CarMapper.xml文件修改如下： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.CarMapper&quot;&gt; &lt;select id=&quot;selectByCarType&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where &lt;!--car_type = #&#123;carType&#125;--&gt; car_type = $&#123;carType&#125; &lt;/select&gt;&lt;/mapper&gt; 再次运行测试程序： 出现异常了，这是为什么呢？看看生成的sql语句： 很显然，${} 是先进行sql语句的拼接，然后再编译，出现语法错误是正常的，因为 燃油车 是一个字符串，在sql语句中应该添加单引号 修改： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.CarMapper&quot;&gt; &lt;select id=&quot;selectByCarType&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where &lt;!--car_type = #&#123;carType&#125;--&gt; &lt;!--car_type = $&#123;carType&#125;--&gt; car_type = &#x27;$&#123;carType&#125;&#x27; &lt;/select&gt;&lt;/mapper&gt; 再执行测试程序： 通过以上测试，可以看出，对于以上这种需求来说，还是建议使用 #{} 的方式。 原则：能用 #{} 就不用 ${} 什么情况下必须使用${}当需要进行sql语句关键字拼接的时候。必须使用${} 需求：通过向sql语句中注入asc或desc关键字，来完成数据的升序或降序排列。 先使用#{}尝试： CarMapper接口： 123456/** * 查询所有的Car * @param ascOrDesc asc或desc * @return */List&lt;Car&gt; selectAll(String ascOrDesc); CarMapper.xml文件： 1234567&lt;select id=&quot;selectAll&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car order by carNum #&#123;key&#125;&lt;/select&gt; 测试程序 123456@Testpublic void testSelectAll()&#123; CarMapper mapper = (CarMapper) SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectAll(&quot;desc&quot;); cars.forEach(car -&gt; System.out.println(car));&#125; 运行： 报错的原因是sql语句不合法，因为采用这种方式传值，最终sql语句会是这样： select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car order by carNum ‘desc’ desc是一个关键字，不能带单引号的，所以在进行sql语句关键字拼接的时候，必须使用${} 使用${} 改造 12345678&lt;select id=&quot;selectAll&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car &lt;!--order by carNum #&#123;key&#125;--&gt; order by carNum $&#123;key&#125;&lt;/select&gt; 再次执行测试程序： 拼接表名业务背景：实际开发中，有的表数据量非常庞大，可能会采用分表方式进行存储，比如每天生成一张表，表的名字与日期挂钩，例如：2022年8月1日生成的表：t_user20220108。2000年1月1日生成的表：t_user20000101。此时前端在进行查询的时候会提交一个具体的日期，比如前端提交的日期为：2000年1月1日，那么后端就会根据这个日期动态拼接表名为：t_user20000101。有了这个表名之后，将表名拼接到sql语句当中，返回查询结果。那么大家思考一下，拼接表名到sql语句当中应该使用#{} 还是 ${} 呢？ 使用#{}会是这样：select * from ‘t_car’ 使用${}会是这样：select * from t_car 123456789101112131415161718&lt;select id=&quot;selectAllByTableName&quot; resultType=&quot;car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from $&#123;tableName&#125;&lt;/select&gt;/** * 根据表名查询所有的Car * @param tableName * @return */List&lt;Car&gt; selectAllByTableName(String tableName);@Testpublic void testSelectAllByTableName()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectAllByTableName(&quot;t_car&quot;); cars.forEach(car -&gt; System.out.println(car));&#125; 执行结果： 批量删除业务背景：一次删除多条记录。 对应的sql语句： delete from t_user where id &#x3D; 1 or id &#x3D; 2 or id &#x3D; 3; delete from t_user where id in(1, 2, 3); 假设现在使用in的方式处理，前端传过来的字符串：1, 2, 3 如果使用mybatis处理，应该使用#{} 还是 ${} 使用#{} ：delete from t_user where id in(‘1,2,3’) 执行错误：1292 - Truncated incorrect DOUBLE value: ‘1,2,3’ 使用${} ：delete from t_user where id in(1, 2, 3) 12345678910111213141516/** * 根据id批量删除 * @param ids * @return */int deleteBatch(String ids);&lt;delete id=&quot;deleteBatch&quot;&gt; delete from t_car where id in($&#123;ids&#125;)&lt;/delete&gt;@Testpublic void testDeleteBatch()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); int count = mapper.deleteBatch(&quot;1,2,3&quot;); System.out.println(&quot;删除了几条记录：&quot; + count); SqlSessionUtil.openSession().commit();&#125; 执行结果： 模糊查询需求：查询奔驰系列的汽车。【只要品牌brand中含有奔驰两个字的都查询出来。】 使用${}1234567891011121314151617181920/** * 根据品牌进行模糊查询 * @param likeBrank * @return */List&lt;Car&gt; selectLikeByBrand(String likeBrank);&lt;select id=&quot;selectLikeByBrand&quot; resultType=&quot;Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where brand like &#x27;%$&#123;brand&#125;%&#x27;&lt;/select&gt;@Testpublic void testSelectLikeByBrand()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectLikeByBrand(&quot;奔驰&quot;); cars.forEach(car -&gt; System.out.println(car));&#125; 执行结果： 使用#{}第一种：concat函数 12345678&lt;select id=&quot;selectLikeByBrand&quot; resultType=&quot;Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where brand like concat(&#x27;%&#x27;,#&#123;brand&#125;,&#x27;%&#x27;)&lt;/select&gt; 执行结果： 第二种：双引号方式 12345678&lt;select id=&quot;selectLikeByBrand&quot; resultType=&quot;Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where brand like &quot;%&quot;#&#123;brand&#125;&quot;%&quot;&lt;/select&gt; 9.2 typeAliases我们来观察一下CarMapper.xml中的配置信息： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.CarMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car order by carNum $&#123;key&#125; &lt;/select&gt; &lt;select id=&quot;selectByCarType&quot; resultType=&quot;com.powernode.mybatis.pojo.Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where car_type = &#x27;$&#123;carType&#125;&#x27; &lt;/select&gt;&lt;/mapper&gt; resultType属性用来指定查询结果集的封装类型，这个名字太长，可以起别名吗？可以。 在mybatis-config.xml文件中使用typeAliases标签来起别名，包括两种方式： 第一种方式：typeAlias123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.powernode.mybatis.pojo.Car&quot; alias=&quot;Car&quot;/&gt;&lt;/typeAliases&gt; 首先要注意typeAliases标签的放置位置，如果不清楚的话，可以看看错误提示信息。 typeAliases标签中的typeAlias可以写多个。 typeAlias： type属性：指定给哪个类起别名 alias属性：别名。 alias属性不是必须的，如果缺省的话，type属性指定的类型名的简类名作为别名。 alias是大小写不敏感的。也就是说假设alias&#x3D;”Car”，再用的时候，可以CAR，也可以car，也可以Car，都行。 第二种方式：package如果一个包下的类太多，每个类都要起别名，会导致typeAlias标签配置较多，所以mybatis用提供package的配置方式，只需要指定包名，该包下的所有类都自动起别名，别名就是简类名。并且别名不区分大小写。 123&lt;typeAliases&gt; &lt;package name=&quot;com.powernode.mybatis.pojo&quot;/&gt;&lt;/typeAliases&gt; package也可以配置多个的。 在SQL映射文件中用一下123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.CarMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;CAR&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car order by carNum $&#123;key&#125; &lt;/select&gt; &lt;select id=&quot;selectByCarType&quot; resultType=&quot;car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where car_type = &#x27;$&#123;carType&#125;&#x27; &lt;/select&gt;&lt;/mapper&gt; 运行测试程序：正常。 9.3 mappersSQL映射文件的配置方式包括四种： resource：从类路径中加载 url：从指定的全限定资源路径中加载 class：使用映射器接口实现类的完全限定类名 package：将包内的映射器接口实现全部注册为映射器 resource这种方式是从类路径中加载配置文件，所以这种方式要求SQL映射文件必须放在resources目录下或其子目录下。 12345&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; url这种方式显然使用了绝对路径的方式，这种配置对SQL映射文件存放的位置没有要求，随意。 12345&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; class如果使用这种方式必须满足以下条件： SQL映射文件和mapper接口放在同一个目录下。 SQL映射文件的名字也必须和mapper接口名一致。 123456&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt; 将CarMapper.xml文件移动到和mapper接口同一个目录下： 在resources目录下新建：com&#x2F;powernode&#x2F;mybatis&#x2F;mapper【这里千万要注意：不能这样新建 com.powernode.mybatis.dao】 将CarMapper.xml文件移动到mapper目录下 修改mybatis-config.xml文件 123&lt;mappers&gt; &lt;mapper class=&quot;com.powernode.mybatis.mapper.CarMapper&quot;/&gt;&lt;/mappers&gt; 运行程序：正常！！！ package如果class较多，可以使用这种package的方式，但前提条件和上一种方式一样。 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=&quot;com.powernode.mybatis.mapper&quot;/&gt;&lt;/mappers&gt; 9.4 idea配置文件模板mybatis-config.xml和SqlMapper.xml文件可以在IDEA中提前创建好模板，以后通过模板创建配置文件。 9.5 插入数据时获取自动生成的主键前提是：主键是自动生成的。 业务背景：一个用户有多个角色。 插入一条新的记录之后，自动生成了主键，而这个主键需要在其他表中使用时。 插入一个用户数据的同时需要给该用户分配角色：需要将生成的用户的id插入到角色表的user_id字段上。 第一种方式：可以先插入用户数据，再写一条查询语句获取id，然后再插入user_id字段。【比较麻烦】 第二种方式：mybatis提供了一种方式更加便捷。 123456/** * 获取自动生成的主键 * @param car */void insertUseGeneratedKeys(Car car); 123&lt;insert id=&quot;insertUseGeneratedKeys&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;)&lt;/insert&gt; 12345678910111213@Testpublic void testInsertUseGeneratedKeys()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); Car car = new Car(); car.setCarNum(&quot;5262&quot;); car.setBrand(&quot;BYD汉&quot;); car.setGuidePrice(30.3); car.setProduceTime(&quot;2020-10-11&quot;); car.setCarType(&quot;新能源&quot;); mapper.insertUseGeneratedKeys(car); SqlSessionUtil.openSession().commit(); System.out.println(car.getId());&#125; 十、MyBatis参数处理（重要，项目应用最多）模块名：mybatis-006-param 表：t_student 表中现有数据： pojo类： 123456789101112131415161718192021package com.powernode.mybatis.pojo;import java.util.Date;/** * 学生类 * @author 老杜 * @version 1.0 * @since 1.0 */public class Student &#123; private Long id; private String name; private Integer age; private Double height; private Character sex; private Date birth; // constructor // setter and getter // toString&#125; 10.1 单个简单类型参数简单类型包括： byte short int long float double char Byte Short Integer Long Float Double Character String java.util.Date java.sql.Date 需求：根据name查、根据id查、根据birth查、根据sex查 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.powernode.mybatis.mapper;import com.powernode.mybatis.pojo.Student;import java.util.Date;import java.util.List;/** * 学生数据Sql映射器 * @author 老杜 * @version 1.0 * @since 1.0 */public interface StudentMapper &#123; /** * 根据name查询 * @param name * @return */ List&lt;Student&gt; selectByName(String name); /** * 根据id查询 * @param id * @return */ Student selectById(Long id); /** * 根据birth查询 * @param birth * @return */ List&lt;Student&gt; selectByBirth(Date birth); /** * 根据sex查询 * @param sex * @return */ List&lt;Student&gt; selectBySex(Character sex);&#125; 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.StudentMapper&quot;&gt; &lt;select id=&quot;selectByName&quot; resultType=&quot;student&quot;&gt; select * from t_student where name = #&#123;name&#125; &lt;/select&gt; &lt;select id=&quot;selectById&quot; resultType=&quot;student&quot;&gt; select * from t_student where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;selectByBirth&quot; resultType=&quot;student&quot;&gt; select * from t_student where birth = #&#123;birth&#125; &lt;/select&gt; &lt;select id=&quot;selectBySex&quot; resultType=&quot;student&quot;&gt; select * from t_student where sex = #&#123;sex&#125; &lt;/select&gt;&lt;/mapper&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.StudentMapper;import com.powernode.mybatis.pojo.Student;import com.powernode.mybatis.utils.SqlSessionUtil;import org.junit.Test;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;public class StudentMapperTest &#123; StudentMapper mapper = SqlSessionUtil.openSession().getMapper(StudentMapper.class); @Test public void testSelectByName()&#123; List&lt;Student&gt; students = mapper.selectByName(&quot;张三&quot;); students.forEach(student -&gt; System.out.println(student)); &#125; @Test public void testSelectById()&#123; Student student = mapper.selectById(2L); System.out.println(student); &#125; @Test public void testSelectByBirth()&#123; try &#123; Date birth = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;2022-08-16&quot;); List&lt;Student&gt; students = mapper.selectByBirth(birth); students.forEach(student -&gt; System.out.println(student)); &#125; catch (ParseException e) &#123; throw new RuntimeException(e); &#125; &#125; @Test public void testSelectBySex()&#123; List&lt;Student&gt; students = mapper.selectBySex(&#x27;男&#x27;); students.forEach(student -&gt; System.out.println(student)); &#125;&#125; 通过测试得知，简单类型对于mybatis来说都是可以自动类型识别的： 也就是说对于mybatis来说，它是可以自动推断出ps.setXxxx()方法的。ps.setString()还是ps.setInt()。它可以自动推断。 其实SQL映射文件中的配置比较完整的写法是： 123&lt;select id=&quot;selectByName&quot; resultType=&quot;student&quot; parameterType=&quot;java.lang.String&quot;&gt; select * from t_student where name = #&#123;name, javaType=String, jdbcType=VARCHAR&#125;&lt;/select&gt; 其中sql语句中的javaType，jdbcType，以及select标签中的parameterType属性，都是用来帮助mybatis进行类型确定的。不过这些配置多数是可以省略的。因为mybatis它有强大的自动类型推断机制。 javaType：可以省略 jdbcType：可以省略 parameterType：可以省略 如果参数只有一个的话，#{} 里面的内容就随便写了。对于 ${} 来说，注意加单引号。 10.2 Map参数需求：根据name和age查询 1234567/*** 根据name和age查询* @param paramMap* @return*/List&lt;Student&gt; selectByParamMap(Map&lt;String,Object&gt; paramMap); 123&lt;select id=&quot;selectByParamMap&quot; resultType=&quot;student&quot;&gt; select * from t_student where name = #&#123;nameKey&#125; and age = #&#123;ageKey&#125;&lt;/select&gt; 12345678910@Testpublic void testSelectByParamMap()&#123; // 准备Map Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(&quot;nameKey&quot;, &quot;张三&quot;); paramMap.put(&quot;ageKey&quot;, 20); List&lt;Student&gt; students = mapper.selectByParamMap(paramMap); students.forEach(student -&gt; System.out.println(student));&#125; 测试运行正常。 这种方式是手动封装Map集合，将每个条件以key和value的形式存放到集合中。然后在使用的时候通过#{map集合的key}来取值。 10.3 实体类参数需求：插入一条Student数据 1234567/** * 保存学生数据 * @param student * @return */int insert(Student student); 123&lt;insert id=&quot;insert&quot;&gt; insert into t_student values(null,#&#123;name&#125;,#&#123;age&#125;,#&#123;height&#125;,#&#123;birth&#125;,#&#123;sex&#125;)&lt;/insert&gt; 1234567891011@Testpublic void testInsert()&#123; Student student = new Student(); student.setName(&quot;李四&quot;); student.setAge(30); student.setHeight(1.70); student.setSex(&#x27;男&#x27;); student.setBirth(new Date()); int count = mapper.insert(student); SqlSessionUtil.openSession().commit();&#125; 运行正常，数据库中成功添加一条数据。 这里需要注意的是：#{} 里面写的是属性名字。这个属性名其本质上是：set&#x2F;get方法名去掉set&#x2F;get之后的名字。 10.4 多参数需求：通过name和sex查询 12345678/** * 根据name和sex查询 * @param name * @param sex * @return */List&lt;Student&gt; selectByNameAndSex(String name, Character sex); 123&lt;select id=&quot;selectByNameAndSex&quot; resultType=&quot;student&quot;&gt; select * from t_student where name = #&#123;name&#125; and sex = #&#123;sex&#125;&lt;/select&gt; 12345@Testpublic void testSelectByNameAndSex()&#123; List&lt;Student&gt; students = mapper.selectByNameAndSex(&quot;张三&quot;, &#x27;女&#x27;); students.forEach(student -&gt; System.out.println(student));&#125; 执行结果： 异常信息描述了：name参数找不到，可用的参数包括[arg1, arg0, param1, param2] 修改StudentMapper.xml配置文件：尝试使用[arg1, arg0, param1, param2]去参数 1234&lt;select id=&quot;selectByNameAndSex&quot; resultType=&quot;student&quot;&gt; &lt;!--select * from t_student where name = #&#123;name&#125; and sex = #&#123;sex&#125;--&gt; select * from t_student where name = #&#123;arg0&#125; and sex = #&#123;arg1&#125;&lt;/select&gt; 运行结果： 再次尝试修改StudentMapper.xml文件 123456&lt;select id=&quot;selectByNameAndSex&quot; resultType=&quot;student&quot;&gt; &lt;!--select * from t_student where name = #&#123;name&#125; and sex = #&#123;sex&#125;--&gt; &lt;!--select * from t_student where name = #&#123;arg0&#125; and sex = #&#123;arg1&#125;--&gt; &lt;!--select * from t_student where name = #&#123;param1&#125; and sex = #&#123;param2&#125;--&gt; select * from t_student where name = #&#123;arg0&#125; and sex = #&#123;param2&#125;&lt;/select&gt; 通过测试可以看到： arg0 是第一个参数 param1是第一个参数 arg1 是第二个参数 param2是第二个参数 实现原理：实际上在mybatis底层会创建一个map集合，以arg0&#x2F;param1为key，以方法上的参数为value，例如以下代码： 12345678Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;arg0&quot;, name);map.put(&quot;arg1&quot;, sex);map.put(&quot;param1&quot;, name);map.put(&quot;param2&quot;, sex);// 所以可以这样取值：#&#123;arg0&#125; #&#123;arg1&#125; #&#123;param1&#125; #&#123;param2&#125;// 其本质就是#&#123;map集合的key&#125; 注意：使用mybatis****3.4.2之前的版本时：要用#{0}和#{1}这种形式。 10.5 @Param注解（命名参数）可以不用arg0 arg1 param1 param2吗？这个map集合的key我们自定义可以吗？当然可以。使用@Param注解即可。这样可以增强可读性。 需求：根据name和age查询 12345678/** * 根据name和age查询 * @param name * @param age * @return */List&lt;Student&gt; selectByNameAndAge(@Param(value=&quot;name&quot;) String name, @Param(&quot;age&quot;) int age); 123&lt;select id=&quot;selectByNameAndAge&quot; resultType=&quot;student&quot;&gt; select * from t_student where name = #&#123;name&#125; and age = #&#123;age&#125;&lt;/select&gt; 12345@Testpublic void testSelectByNameAndAge()&#123; List&lt;Student&gt; stus = mapper.selectByNameAndAge(&quot;张三&quot;, 20); stus.forEach(student -&gt; System.out.println(student));&#125; 通过测试，一切正常。 核心：@Param(“这里填写的其实就是map集合的key“) 10.6 @Param源码分析 十一、MyBatis查询语句专题（重要）模块名：mybatis-007-select 打包方式：jar 引入依赖：mysql驱动依赖、mybatis依赖、logback依赖、junit依赖。 引入配置文件：jdbc.properties、mybatis-config.xml、logback.xml 创建pojo类：Car 创建Mapper接口：CarMapper 创建Mapper接口对应的映射文件：com&#x2F;powernode&#x2F;mybatis&#x2F;mapper&#x2F;CarMapper.xml 创建单元测试：CarMapperTest 拷贝工具类：SqlSessionUtil 11.1 返回Car当查询的结果，有对应的实体类，并且查询结果只有一条时： 123456789101112131415161718package com.powernode.mybatis.mapper;import com.powernode.mybatis.pojo.Car;/** * Car SQL映射器 * @version 1.0 * @since 1.0 */public interface CarMapper &#123; /** * 根据id主键查询：结果最多只有一条 * @param id * @return */ Car selectById(Long id);&#125; 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.CarMapper&quot;&gt; &lt;select id=&quot;selectById&quot; resultType=&quot;Car&quot;&gt; select id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType from t_car where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 12345678910111213141516package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.CarMapper;import com.powernode.mybatis.pojo.Car;import com.powernode.mybatis.utils.SqlSessionUtil;import org.junit.Test;public class CarMapperTest &#123; @Test public void testSelectById()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); Car car = mapper.selectById(35L); System.out.println(car); &#125;&#125; 执行结果： 查询结果是一条的话可以使用List集合接收吗？当然可以。 12345/*** 根据id主键查询：结果最多只有一条，可以放到List集合中吗？* @return*/List&lt;Car&gt; selectByIdToList(Long id); 123&lt;select id=&quot;selectByIdToList&quot; resultType=&quot;Car&quot;&gt; select id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType from t_car where id = #&#123;id&#125;&lt;/select&gt; 123456@Testpublic void testSelectByIdToList()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectByIdToList(35L); System.out.println(cars);&#125; 执行结果： 11.2 返回List当查询的记录条数是多条的时候，必须使用集合接收。如果使用单个实体类接收会出现异常。 12345/*** 查询所有的Car* @return*/List&lt;Car&gt; selectAll(); 123&lt;select id=&quot;selectAll&quot; resultType=&quot;Car&quot;&gt; select id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType from t_car&lt;/select&gt; 123456@Testpublic void testSelectAll()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectAll(); cars.forEach(car -&gt; System.out.println(car));&#125; 如果返回多条记录，采用单个实体类接收会怎样？ 12345/*** 查询多条记录，采用单个实体类接收会怎样？* @return*/Car selectAll2(); 123&lt;select id=&quot;selectAll2&quot; resultType=&quot;Car&quot;&gt; select id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType from t_car&lt;/select&gt; 123456@Testpublic void testSelectAll2()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); Car car = mapper.selectAll2(); System.out.println(car);&#125; 执行结果： 11.3 返回Map当返回的数据，没有合适的实体类对应的话，可以采用Map集合接收。字段名做key，字段值做value。 查询如果可以保证只有一条数据，则返回一个Map集合即可。 1234567/** * 通过id查询一条记录，返回Map集合 * @param id * @return */Map&lt;String, Object&gt; selectByIdRetMap(Long id); 123&lt;select id=&quot;selectByIdRetMap&quot; resultType=&quot;map&quot;&gt; select id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType from t_car where id = #&#123;id&#125;&lt;/select&gt; resultMap&#x3D;”map”，这是因为mybatis内置了很多别名。【参见mybatis开发手册】 123456@Testpublic void testSelectByIdRetMap()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); Map&lt;String,Object&gt; car = mapper.selectByIdRetMap(35L); System.out.println(car);&#125; 执行结果： 当然，如果返回一个Map集合，可以将Map集合放到List集合中吗？当然可以，这里就不再测试了。 反过来，如果返回的不是一条记录，是多条记录的话，只采用单个Map集合接收，这样同样会出现之前的异常：TooManyResultsException 11.4 返回List查询结果条数大于等于1条数据，则可以返回一个存储Map集合的List集合。List等同于List 12345/** * 查询所有的Car，返回一个List集合。List集合中存储的是Map集合。 * @return */List&lt;Map&lt;String,Object&gt;&gt; selectAllRetListMap(); 123&lt;select id=&quot;selectAllRetListMap&quot; resultType=&quot;map&quot;&gt; select id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType from t_car&lt;/select&gt; 123456@Testpublic void testSelectAllRetListMap()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Map&lt;String,Object&gt;&gt; cars = mapper.selectAllRetListMap(); System.out.println(cars);&#125; 执行结果： 1234567[ &#123;carType=燃油车, carNum=103, guidePrice=50.30, produceTime=2020-10-01, id=33, brand=奔驰E300L&#125;, &#123;carType=电车, carNum=102, guidePrice=30.23, produceTime=2018-09-10, id=34, brand=比亚迪汉&#125;, &#123;carType=燃油车, carNum=103, guidePrice=50.30, produceTime=2020-10-01, id=35, brand=奔驰E300L&#125;, &#123;carType=燃油车, carNum=103, guidePrice=33.23, produceTime=2020-10-11, id=36, brand=奔驰C200&#125;, ......] 11.5 返回Map&lt;String,Map&gt;拿Car的id做key，以后取出对应的Map集合时更方便。 12345678/** * 获取所有的Car，返回一个Map集合。 * Map集合的key是Car的id。 * Map集合的value是对应Car。 * @return */@MapKey(&quot;id&quot;)Map&lt;Long,Map&lt;String,Object&gt;&gt; selectAllRetMap(); 123&lt;select id=&quot;selectAllRetMap&quot; resultType=&quot;map&quot;&gt; select id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType from t_car&lt;/select&gt; 123456@Testpublic void testSelectAllRetMap()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); Map&lt;Long,Map&lt;String,Object&gt;&gt; cars = mapper.selectAllRetMap(); System.out.println(cars);&#125; 执行结果： 1234567&#123;64=&#123;carType=燃油车, carNum=133, guidePrice=50.30, produceTime=2020-01-10, id=64, brand=丰田霸道&#125;, 66=&#123;carType=燃油车, carNum=133, guidePrice=50.30, produceTime=2020-01-10, id=66, brand=丰田霸道&#125;, 67=&#123;carType=燃油车, carNum=133, guidePrice=50.30, produceTime=2020-01-10, id=67, brand=丰田霸道&#125;, 69=&#123;carType=燃油车, carNum=133, guidePrice=50.30, produceTime=2020-01-10, id=69, brand=丰田霸道&#125;,......&#125; 11.6 resultMap结果映射查询结果的列名和java对象的属性名对应不上怎么办？ 第一种方式：as 给列起别名 第二种方式：使用resultMap进行结果映射 第三种方式：是否开启驼峰命名自动映射（配置settings） 使用resultMap进行结果映射12345/** * 查询所有Car，使用resultMap进行结果映射 * @return */List&lt;Car&gt; selectAllByResultMap(); 123456789101112131415161718192021&lt;!-- resultMap: id：这个结果映射的标识，作为select标签的resultMap属性的值。 type：结果集要映射的类。可以使用别名。--&gt;&lt;resultMap id=&quot;carResultMap&quot; type=&quot;car&quot;&gt; &lt;!--对象的唯一标识，官方解释是：为了提高mybatis的性能。建议写上。--&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;carNum&quot; column=&quot;car_num&quot;/&gt; &lt;!--当属性名和数据库列名一致时，可以省略。但建议都写上。--&gt; &lt;!--javaType用来指定属性类型。jdbcType用来指定列类型。一般可以省略。--&gt; &lt;result property=&quot;brand&quot; column=&quot;brand&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;guidePrice&quot; column=&quot;guide_price&quot;/&gt; &lt;result property=&quot;produceTime&quot; column=&quot;produce_time&quot;/&gt; &lt;result property=&quot;carType&quot; column=&quot;car_type&quot;/&gt;&lt;/resultMap&gt;&lt;!--resultMap属性的值必须和resultMap标签中id属性值一致。--&gt;&lt;select id=&quot;selectAllByResultMap&quot; resultMap=&quot;carResultMap&quot;&gt; select * from t_car&lt;/select&gt; 123456@Testpublic void testSelectAllByResultMap()&#123; CarMapper carMapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = carMapper.selectAllByResultMap(); System.out.println(cars);&#125; 执行结果正常。 是否开启驼峰命名自动映射使用这种方式的前提是：属性名遵循Java的命名规范，数据库表的列名遵循SQL的命名规范。 Java命名规范：首字母小写，后面每个单词首字母大写，遵循驼峰命名方式。 SQL命名规范：全部小写，单词之间采用下划线分割。 比如以下的对应关系： 实体类中的属性名 数据库表的列名 carNum car_num carType car_type produceTime produce_time 如何启用该功能，在mybatis-config.xml文件中进行配置： 1234&lt;!--放在properties标签后面--&gt;&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 12345678/*** 查询所有Car，启用驼峰命名自动映射* @return*/List&lt;Car&gt; selectAllByMapUnderscoreToCamelCase();&lt;select id=&quot;selectAllByMapUnderscoreToCamelCase&quot; resultType=&quot;Car&quot;&gt; select * from t_car&lt;/select&gt; 123456@Testpublic void testSelectAllByMapUnderscoreToCamelCase()&#123; CarMapper carMapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = carMapper.selectAllByMapUnderscoreToCamelCase(); System.out.println(cars);&#125; 执行结果正常。 11.7 返回总记录条数需求：查询总记录条数 12345678910111213141516171819/** * 获取总记录条数 * @return */Long selectTotal();&lt;!--long是别名，可参考mybatis开发手册。--&gt;&lt;select id=&quot;selectTotal&quot; resultType=&quot;long&quot;&gt; select count(*) from t_car&lt;/select&gt; @Testpublic void testSelectTotal()&#123; CarMapper carMapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); Long total = carMapper.selectTotal(); System.out.println(total);&#125; 十二、动态SQL有的业务场景，也需要SQL语句进行动态拼接，例如： 批量删除 1delete from t_car where id in(1,2,3,4,5,6,......这里的值是动态的，根据用户选择的id不同，值是不同的); 多条件查询 1select * from t_car where brand like &#x27;丰田%&#x27; and guide_price &gt; 30 and .....; 创建模块：mybatis-008-dynamic-sql 打包方式：jar 引入依赖：mysql驱动依赖、mybatis依赖、junit依赖、logback依赖 pojo：com.powernode.mybatis.pojo.Car mapper接口：com.powernode.mybatis.mapper.CarMapper 引入配置文件：mybatis-config.xml、jdbc.properties、logback.xml mapper配置文件：com&#x2F;powernode&#x2F;mybatis&#x2F;mapper&#x2F;CarMapper.xml 编写测试类：com.powernode.mybatis.test.CarMapperTest 拷贝工具类：SqlSessionUtil 12.1 if标签需求：多条件查询。 可能的条件包括：品牌（brand）、指导价格（guide_price）、汽车类型（car_type） 1234567891011121314151617181920package com.powernode.mybatis.mapper;import com.powernode.mybatis.pojo.Car;import org.apache.ibatis.annotations.Param;import java.util.List;public interface CarMapper &#123; /** * 根据多条件查询Car * @param brand * @param guidePrice * @param carType * @return */ List&lt;Car&gt; selectByMultiCondition(@Param(&quot;brand&quot;) String brand, @Param(&quot;guidePrice&quot;) Double guidePrice, @Param(&quot;carType&quot;) String carType);&#125; 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.CarMapper&quot;&gt; &lt;select id=&quot;selectByMultiCondition&quot; resultType=&quot;car&quot;&gt; select * from t_car where &lt;if test=&quot;brand != null and brand != &#x27;&#x27;&quot;&gt; brand like #&#123;brand&#125;&quot;%&quot; &lt;/if&gt; &lt;if test=&quot;guidePrice != null and guidePrice != &#x27;&#x27;&quot;&gt; and guide_price &gt;= #&#123;guidePrice&#125; &lt;/if&gt; &lt;if test=&quot;carType != null and carType != &#x27;&#x27;&quot;&gt; and car_type = #&#123;carType&#125; &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.CarMapper;import com.powernode.mybatis.pojo.Car;import com.powernode.mybatis.utils.SqlSessionUtil;import org.junit.Test;import java.util.List;public class CarMapperTest &#123; @Test public void testSelectByMultiCondition()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectByMultiCondition(&quot;丰田&quot;, 20.0, &quot;燃油车&quot;); System.out.println(cars); &#125;&#125; 执行结果： 如果第一个条件为空，剩下两个条件不为空，会是怎样呢？ 1List&lt;Car&gt; cars = mapper.selectByMultiCondition(&quot;&quot;, 20.0, &quot;燃油车&quot;); 执行结果： 报错了，SQL语法有问题，where后面出现了and。这该怎么解决呢？ 可以where后面添加一个恒成立的条件。 执行结果： 如果三个条件都是空，有影响吗？ 1List&lt;Car&gt; cars = mapper.selectByMultiCondition(&quot;&quot;, null, &quot;&quot;); 执行结果： 三个条件都不为空呢？ 1List&lt;Car&gt; cars = mapper.selectByMultiCondition(&quot;丰田&quot;, 20.0, &quot;燃油车&quot;); 执行结果： 12.2 where标签where标签的作用：让where子句更加动态智能。 所有条件都为空时，where标签保证不会生成where子句。 自动去除某些条件前面多余的and或or。 继续使用if标签中的需求。 12345678910/*** 根据多条件查询Car，使用where标签* @param brand* @param guidePrice* @param carType* @return*/List&lt;Car&gt; selectByMultiConditionWithWhere(@Param(&quot;brand&quot;) String brand, @Param(&quot;guidePrice&quot;) Double guidePrice, @Param(&quot;carType&quot;) String carType); 1234567891011121314&lt;select id=&quot;selectByMultiConditionWithWhere&quot; resultType=&quot;car&quot;&gt; select * from t_car &lt;where&gt; &lt;if test=&quot;brand != null and brand != &#x27;&#x27;&quot;&gt; and brand like #&#123;brand&#125;&quot;%&quot; &lt;/if&gt; &lt;if test=&quot;guidePrice != null and guidePrice != &#x27;&#x27;&quot;&gt; and guide_price &gt;= #&#123;guidePrice&#125; &lt;/if&gt; &lt;if test=&quot;carType != null and carType != &#x27;&#x27;&quot;&gt; and car_type = #&#123;carType&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 123456@Testpublic void testSelectByMultiConditionWithWhere()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectByMultiConditionWithWhere(&quot;丰田&quot;, 20.0, &quot;燃油车&quot;); System.out.println(cars);&#125; 运行结果： 如果所有条件都是空呢？ 1List&lt;Car&gt; cars = mapper.selectByMultiConditionWithWhere(&quot;&quot;, null, &quot;&quot;); 运行结果： 它可以自动去掉前面多余的and，那可以自动去掉前面多余的or吗？ 123456789101112131415List&lt;Car&gt; cars = mapper.selectByMultiConditionWithWhere(&quot;丰田&quot;, 20.0, &quot;燃油车&quot;);&lt;select id=&quot;selectByMultiConditionWithWhere&quot; resultType=&quot;car&quot;&gt; select * from t_car &lt;where&gt; &lt;if test=&quot;brand != null and brand != &#x27;&#x27;&quot;&gt; or brand like #&#123;brand&#125;&quot;%&quot; &lt;/if&gt; &lt;if test=&quot;guidePrice != null and guidePrice != &#x27;&#x27;&quot;&gt; and guide_price &gt;= #&#123;guidePrice&#125; &lt;/if&gt; &lt;if test=&quot;carType != null and carType != &#x27;&#x27;&quot;&gt; and car_type = #&#123;carType&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 执行结果： 它可以自动去掉前面多余的and，那可以自动去掉后面多余的and吗？ 12345678910111213141516&lt;select id=&quot;selectByMultiConditionWithWhere&quot; resultType=&quot;car&quot;&gt; select * from t_car &lt;where&gt; &lt;if test=&quot;brand != null and brand != &#x27;&#x27;&quot;&gt; brand like #&#123;brand&#125;&quot;%&quot; and &lt;/if&gt; &lt;if test=&quot;guidePrice != null and guidePrice != &#x27;&#x27;&quot;&gt; guide_price &gt;= #&#123;guidePrice&#125; and &lt;/if&gt; &lt;if test=&quot;carType != null and carType != &#x27;&#x27;&quot;&gt; car_type = #&#123;carType&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;// 让最后一个条件为空List&lt;Car&gt; cars = mapper.selectByMultiConditionWithWhere(&quot;丰田&quot;, 20.0, &quot;&quot;); 运行结果： 很显然，后面多余的and是不会被去除的。 12.3 trim标签trim标签的属性： prefix：在trim标签中的语句前添加内容 suffix：在trim标签中的语句后添加内容 prefixOverrides：前缀覆盖掉（去掉） suffixOverrides：后缀覆盖掉（去掉） 123456789/*** 根据多条件查询Car，使用trim标签* @param brand* @param guidePrice* @param carType* @return*/List&lt;Car&gt; selectByMultiConditionWithTrim(@Param(&quot;brand&quot;) String brand, @Param(&quot;guidePrice&quot;) Double guidePrice, @Param(&quot;carType&quot;) String carType); 1234567891011121314&lt;select id=&quot;selectByMultiConditionWithTrim&quot; resultType=&quot;car&quot;&gt; select * from t_car &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;brand != null and brand != &#x27;&#x27;&quot;&gt; brand like #&#123;brand&#125;&quot;%&quot; and &lt;/if&gt; &lt;if test=&quot;guidePrice != null and guidePrice != &#x27;&#x27;&quot;&gt; guide_price &gt;= #&#123;guidePrice&#125; and &lt;/if&gt; &lt;if test=&quot;carType != null and carType != &#x27;&#x27;&quot;&gt; car_type = #&#123;carType&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 123456@Testpublic void testSelectByMultiConditionWithTrim()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectByMultiConditionWithTrim(&quot;丰田&quot;, 20.0, &quot;&quot;); System.out.println(cars);&#125; 如果所有条件为空，where会被加上吗？ 1List&lt;Car&gt; cars = mapper.selectByMultiConditionWithTrim(&quot;&quot;, null, &quot;&quot;); 执行结果： 12.4 set标签主要使用在update语句当中，用来生成set关键字，同时去掉最后多余的“,” 比如我们只更新提交的不为空的字段，如果提交的数据是空或者””，那么这个字段我们将不更新。 123456/*** 更新信息，使用set标签* @param car* @return*/int updateWithSet(Car car); 1234567891011&lt;update id=&quot;updateWithSet&quot;&gt; update t_car &lt;set&gt; &lt;if test=&quot;carNum != null and carNum != &#x27;&#x27;&quot;&gt;car_num = #&#123;carNum&#125;,&lt;/if&gt; &lt;if test=&quot;brand != null and brand != &#x27;&#x27;&quot;&gt;brand = #&#123;brand&#125;,&lt;/if&gt; &lt;if test=&quot;guidePrice != null and guidePrice != &#x27;&#x27;&quot;&gt;guide_price = #&#123;guidePrice&#125;,&lt;/if&gt; &lt;if test=&quot;produceTime != null and produceTime != &#x27;&#x27;&quot;&gt;produce_time = #&#123;produceTime&#125;,&lt;/if&gt; &lt;if test=&quot;carType != null and carType != &#x27;&#x27;&quot;&gt;car_type = #&#123;carType&#125;,&lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; 12345678@Testpublic void testUpdateWithSet()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); Car car = new Car(38L,&quot;1001&quot;,&quot;丰田霸道2&quot;,10.0,&quot;&quot;,null); int count = mapper.updateWithSet(car); System.out.println(count); SqlSessionUtil.openSession().commit();&#125; 执行结果： 12.5 choose when otherwise这三个标签是在一起使用的： 123456&lt;choose&gt; &lt;when&gt;&lt;/when&gt; &lt;when&gt;&lt;/when&gt; &lt;when&gt;&lt;/when&gt; &lt;otherwise&gt;&lt;/otherwise&gt;&lt;/choose&gt; 等同于： 1234567891011if()&#123; &#125;else if()&#123; &#125;else if()&#123; &#125;else if()&#123; &#125;else&#123;&#125; 只有一个分支会被选择！！！！ 需求：先根据品牌查询，如果没有提供品牌，再根据指导价格查询，如果没有提供指导价格，就根据生产日期查询。 12345678/*** 使用choose when otherwise标签查询* @param brand* @param guidePrice* @param produceTime* @return*/List&lt;Car&gt; selectWithChoose(@Param(&quot;brand&quot;) String brand, @Param(&quot;guidePrice&quot;) Double guidePrice, @Param(&quot;produceTime&quot;) String produceTime); 12345678910111213141516&lt;select id=&quot;selectWithChoose&quot; resultType=&quot;car&quot;&gt; select * from t_car &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;brand != null and brand != &#x27;&#x27;&quot;&gt; brand like #&#123;brand&#125;&quot;%&quot; &lt;/when&gt; &lt;when test=&quot;guidePrice != null and guidePrice != &#x27;&#x27;&quot;&gt; guide_price &gt;= #&#123;guidePrice&#125; &lt;/when&gt; &lt;otherwise&gt; produce_time &gt;= #&#123;produceTime&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 123456789@Testpublic void testSelectWithChoose()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); //List&lt;Car&gt; cars = mapper.selectWithChoose(&quot;丰田霸道&quot;, 20.0, &quot;2000-10-10&quot;); //List&lt;Car&gt; cars = mapper.selectWithChoose(&quot;&quot;, 20.0, &quot;2000-10-10&quot;); //List&lt;Car&gt; cars = mapper.selectWithChoose(&quot;&quot;, null, &quot;2000-10-10&quot;); List&lt;Car&gt; cars = mapper.selectWithChoose(&quot;&quot;, null, &quot;&quot;); System.out.println(cars);&#125; 12.6 foreach标签循环数组或集合，动态生成sql，比如这样的SQL： 123456delete from t_car where id in(1,2,3);delete from t_car where id = 1 or id = 2 or id = 3;insert into t_car values (null,&#x27;1001&#x27;,&#x27;凯美瑞&#x27;,35.0,&#x27;2010-10-11&#x27;,&#x27;燃油车&#x27;), (null,&#x27;1002&#x27;,&#x27;比亚迪唐&#x27;,31.0,&#x27;2020-11-11&#x27;,&#x27;新能源&#x27;), (null,&#x27;1003&#x27;,&#x27;比亚迪宋&#x27;,32.0,&#x27;2020-10-11&#x27;,&#x27;新能源&#x27;) 批量删除 用in来删除 123456/*** 通过foreach完成批量删除* @param ids* @return*/int deleteBatchByForeach(@Param(&quot;ids&quot;) Long[] ids); 12345678910111213&lt;!--collection：集合或数组item：集合或数组中的元素separator：分隔符open：foreach标签中所有内容的开始close：foreach标签中所有内容的结束--&gt;&lt;delete id=&quot;deleteBatchByForeach&quot;&gt; delete from t_car where id in &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/delete&gt; 1234567@Testpublic void testDeleteBatchByForeach()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); int count = mapper.deleteBatchByForeach(new Long[]&#123;40L, 41L, 42L&#125;); System.out.println(&quot;删除了几条记录：&quot; + count); SqlSessionUtil.openSession().commit();&#125; 执行结果： 用or来删除 123456/*** 通过foreach完成批量删除* @param ids* @return*/int deleteBatchByForeach2(@Param(&quot;ids&quot;) Long[] ids); 123456&lt;delete id=&quot;deleteBatchByForeach2&quot;&gt; delete from t_car where &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;or&quot;&gt; id = #&#123;id&#125; &lt;/foreach&gt;&lt;/delete&gt; 1234567@Testpublic void testDeleteBatchByForeach2()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); int count = mapper.deleteBatchByForeach2(new Long[]&#123;40L, 41L, 42L&#125;); System.out.println(&quot;删除了几条记录：&quot; + count); SqlSessionUtil.openSession().commit();&#125; 执行结果： 批量添加123456/*** 批量添加，使用foreach标签* @param cars* @return*/int insertBatchByForeach(@Param(&quot;cars&quot;) List&lt;Car&gt; cars); 123456&lt;insert id=&quot;insertBatchByForeach&quot;&gt; insert into t_car values &lt;foreach collection=&quot;cars&quot; item=&quot;car&quot; separator=&quot;,&quot;&gt; (null,#&#123;car.carNum&#125;,#&#123;car.brand&#125;,#&#123;car.guidePrice&#125;,#&#123;car.produceTime&#125;,#&#123;car.carType&#125;) &lt;/foreach&gt;&lt;/insert&gt; 1234567891011@Testpublic void testInsertBatchByForeach()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); Car car1 = new Car(null, &quot;2001&quot;, &quot;兰博基尼&quot;, 100.0, &quot;1998-10-11&quot;, &quot;燃油车&quot;); Car car2 = new Car(null, &quot;2001&quot;, &quot;兰博基尼&quot;, 100.0, &quot;1998-10-11&quot;, &quot;燃油车&quot;); Car car3 = new Car(null, &quot;2001&quot;, &quot;兰博基尼&quot;, 100.0, &quot;1998-10-11&quot;, &quot;燃油车&quot;); List&lt;Car&gt; cars = Arrays.asList(car1, car2, car3); int count = mapper.insertBatchByForeach(cars); System.out.println(&quot;插入了几条记录&quot; + count); SqlSessionUtil.openSession().commit();&#125; 执行结果： 12.7 sql标签与include标签sql标签用来声明sql片段 include标签用来将声明的sql片段包含到某个sql语句当中 作用：代码复用。易维护。 12345678910111213&lt;sql id=&quot;carCols&quot;&gt;id,car_num carNum,brand,guide_price guidePrice,produce_time produceTime,car_type carType&lt;/sql&gt;&lt;select id=&quot;selectAllRetMap&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;carCols&quot;/&gt; from t_car&lt;/select&gt;&lt;select id=&quot;selectAllRetListMap&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;carCols&quot;/&gt; carType from t_car&lt;/select&gt;&lt;select id=&quot;selectByIdRetMap&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;carCols&quot;/&gt; from t_car where id = #&#123;id&#125;&lt;/select&gt; 十三、MyBatis的高级映射及延迟加载模块名：mybatis-009-advanced-mapping 打包方式：jar 依赖：mybatis依赖、mysql驱动依赖、junit依赖、logback依赖 配置文件：mybatis-config.xml、logback.xml、jdbc.properties 拷贝工具类：SqlSessionUtil 准备数据库表：一个班级对应多个学生。班级表：t_clazz。学生表：t_student 创建pojo：Student、Clazz 1234567891011121314151617181920212223242526package com.powernode.mybatis.pojo;/** * 学生类 * @author 老杜 * @version 1.0 * @since 1.0 */public class Student &#123; private Integer sid; private String sname; //......&#125;package com.powernode.mybatis.pojo;/** * 班级类 * @author 老杜 * @version 1.0 * @since 1.0 */public class Clazz &#123; private Integer cid; private String cname; //......&#125; 创建mapper接口：StudentMapper、ClazzMapper 创建mapper映射文件：StudentMapper.xml、ClazzMapper.xml 13.1 多对一多种方式，常见的包括三种： 第一种方式：一条SQL语句，级联属性映射。 第二种方式：一条SQL语句，association。 第三种方式：两条SQL语句，分步查询。（这种方式常用：优点一是可复用。优点二是支持懒加载。） 第一种方式：级联属性映射pojo类Student中添加一个属性：Clazz clazz; 表示学生关联的班级对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.powernode.mybatis.pojo;/** * 学生类 * @author 老杜 * @version 1.0 * @since 1.0 */public class Student &#123; private Integer sid; private String sname; private Clazz clazz; public Clazz getClazz() &#123; return clazz; &#125; public void setClazz(Clazz clazz) &#123; this.clazz = clazz; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;sid=&quot; + sid + &quot;, sname=&#x27;&quot; + sname + &#x27;\\&#x27;&#x27; + &quot;, clazz=&quot; + clazz + &#x27;&#125;&#x27;; &#125; public Student() &#123; &#125; public Student(Integer sid, String sname) &#123; this.sid = sid; this.sname = sname; &#125; public Integer getSid() &#123; return sid; &#125; public void setSid(Integer sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125;&#125; 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.StudentMapper&quot;&gt; &lt;resultMap id=&quot;studentResultMap&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;sname&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;clazz.cid&quot; column=&quot;cid&quot;/&gt; &lt;result property=&quot;clazz.cname&quot; column=&quot;cname&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBySid&quot; resultMap=&quot;studentResultMap&quot;&gt; select s.*, c.* from t_student s join t_clazz c on s.cid = c.cid where sid = #&#123;sid&#125; &lt;/select&gt;&lt;/mapper&gt; 123456789101112131415package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.StudentMapper;import com.powernode.mybatis.pojo.Student;import com.powernode.mybatis.utils.SqlSessionUtil;import org.junit.Test;public class StudentMapperTest &#123; @Test public void testSelectBySid()&#123; StudentMapper mapper = SqlSessionUtil.openSession().getMapper(StudentMapper.class); Student student = mapper.selectBySid(1); System.out.println(student); &#125;&#125; 执行结果： 第二种方式：association其他位置都不需要修改，只需要修改resultMap中的配置：association即可。 12345678&lt;resultMap id=&quot;studentResultMap&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;sname&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;clazz&quot; javaType=&quot;Clazz&quot;&gt; &lt;id property=&quot;cid&quot; column=&quot;cid&quot;/&gt; &lt;result property=&quot;cname&quot; column=&quot;cname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; association翻译为：关联。 学生对象关联一个班级对象。 第三种方式：分步查询其他位置不需要修改，只需要修改以及添加以下三处： 第一处：association中select位置填写sqlId。sqlId&#x3D;namespace+id。其中column属性作为这条子sql语句的条件。 1234567891011&lt;resultMap id=&quot;studentResultMap&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;sname&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;clazz&quot; select=&quot;com.powernode.mybatis.mapper.ClazzMapper.selectByCid&quot; column=&quot;cid&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectBySid&quot; resultMap=&quot;studentResultMap&quot;&gt; select s.* from t_student s where sid = #&#123;sid&#125;&lt;/select&gt; 第二处：在ClazzMapper接口中添加方法 12345678910111213141516171819package com.powernode.mybatis.mapper;import com.powernode.mybatis.pojo.Clazz;/** * Clazz映射器接口 * @author 老杜 * @version 1.0 * @since 1.0 */public interface ClazzMapper &#123; /** * 根据cid获取Clazz信息 * @param cid * @return */ Clazz selectByCid(Integer cid);&#125; 第三处：在ClazzMapper.xml文件中进行配置 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.ClazzMapper&quot;&gt; &lt;select id=&quot;selectByCid&quot; resultType=&quot;Clazz&quot;&gt; select * from t_clazz where cid = #&#123;cid&#125; &lt;/select&gt;&lt;/mapper&gt; 执行结果，可以很明显看到先后有两条sql语句执行： 分步优点： 第一个优点：代码复用性增强。 第二个优点：支持延迟加载。【暂时访问不到的数据可以先不查询。提高程序的执行效率。】 13.2 多对一延迟加载要想支持延迟加载，非常简单，只需要在association标签中添加fetchType&#x3D;”lazy”即可。 修改StudentMapper.xml文件： 12345678&lt;resultMap id=&quot;studentResultMap&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;sname&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;clazz&quot; select=&quot;com.powernode.mybatis.mapper.ClazzMapper.selectByCid&quot; column=&quot;cid&quot; fetchType=&quot;lazy&quot;/&gt;&lt;/resultMap&gt; 我们现在只查询学生名字，修改测试程序： 1234567891011public class StudentMapperTest &#123; @Test public void testSelectBySid()&#123; StudentMapper mapper = SqlSessionUtil.openSession().getMapper(StudentMapper.class); Student student = mapper.selectBySid(1); //System.out.println(student); // 只获取学生姓名 String sname = student.getSname(); System.out.println(&quot;学生姓名：&quot; + sname); &#125;&#125; 如果后续需要使用到学生所在班级的名称，这个时候才会执行关联的sql语句，修改测试程序： 1234567891011121314public class StudentMapperTest &#123; @Test public void testSelectBySid()&#123; StudentMapper mapper = SqlSessionUtil.openSession().getMapper(StudentMapper.class); Student student = mapper.selectBySid(1); //System.out.println(student); // 只获取学生姓名 String sname = student.getSname(); System.out.println(&quot;学生姓名：&quot; + sname); // 到这里之后，想获取班级名字了 String cname = student.getClazz().getCname(); System.out.println(&quot;学生的班级名称：&quot; + cname); &#125;&#125; 通过以上的执行结果可以看到，只有当使用到班级名称之后，才会执行关联的sql语句，这就是延迟加载。 在mybatis中如何开启全局的延迟加载呢？需要setting配置，如下： 123&lt;settings&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 把fetchType&#x3D;”lazy”去掉。 执行以下程序： 1234567891011121314public class StudentMapperTest &#123; @Test public void testSelectBySid()&#123; StudentMapper mapper = SqlSessionUtil.openSession().getMapper(StudentMapper.class); Student student = mapper.selectBySid(1); //System.out.println(student); // 只获取学生姓名 String sname = student.getSname(); System.out.println(&quot;学生姓名：&quot; + sname); // 到这里之后，想获取班级名字了 String cname = student.getClazz().getCname(); System.out.println(&quot;学生的班级名称：&quot; + cname); &#125;&#125; 通过以上的测试可以看出，我们已经开启了全局延迟加载策略。 开启全局延迟加载之后，所有的sql都会支持延迟加载，如果某个sql你不希望它支持延迟加载怎么办呢？将fetchType设置为eager： 12345678&lt;resultMap id=&quot;studentResultMap&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;sname&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;clazz&quot; select=&quot;com.powernode.mybatis.mapper.ClazzMapper.selectByCid&quot; column=&quot;cid&quot; fetchType=&quot;eager&quot;/&gt;&lt;/resultMap&gt; 这样的话，针对某个特定的sql，你就关闭了延迟加载机制。 后期我们要不要开启延迟加载机制，主要看实际的业务需求是怎样的。 13.3 一对多 一对多的实现，通常是在一的一方中有List集合属性。 在Clazz类中添加List stus; 属性。 12345678public class Clazz &#123; private Integer cid; private String cname; private List&lt;Student&gt; stus; // set get方法 // 构造方法 // toString方法&#125; 一对多的实现通常包括两种实现方式： 第一种方式：collection 第二种方式：分步查询 第一种方式：collection123456789101112131415161718192021222324252627package com.powernode.mybatis.mapper;import com.powernode.mybatis.pojo.Clazz;/** * Clazz映射器接口 * @author 老杜 * @version 1.0 * @since 1.0 */public interface ClazzMapper &#123; /** * 根据cid获取Clazz信息 * @param cid * @return */ Clazz selectByCid(Integer cid); /** * 根据班级编号查询班级信息。同时班级中所有的学生信息也要查询。 * @param cid * @return */ Clazz selectClazzAndStusByCid(Integer cid);&#125; 123456789101112&lt;resultMap id=&quot;clazzResultMap&quot; type=&quot;Clazz&quot;&gt; &lt;id property=&quot;cid&quot; column=&quot;cid&quot;/&gt; &lt;result property=&quot;cname&quot; column=&quot;cname&quot;/&gt; &lt;collection property=&quot;stus&quot; ofType=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;sname&quot; column=&quot;sname&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectClazzAndStusByCid&quot; resultMap=&quot;clazzResultMap&quot;&gt; select * from t_clazz c join t_student s on c.cid = s.cid where c.cid = #&#123;cid&#125;&lt;/select&gt; 注意是ofType，表示“集合中的类型”。 123456789101112131415package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.ClazzMapper;import com.powernode.mybatis.pojo.Clazz;import com.powernode.mybatis.utils.SqlSessionUtil;import org.junit.Test;public class ClazzMapperTest &#123; @Test public void testSelectClazzAndStusByCid() &#123; ClazzMapper mapper = SqlSessionUtil.openSession().getMapper(ClazzMapper.class); Clazz clazz = mapper.selectClazzAndStusByCid(1001); System.out.println(clazz); &#125;&#125; 执行结果： 第二种方式：分步查询修改以下三个位置即可： 12345678910111213&lt;resultMap id=&quot;clazzResultMap&quot; type=&quot;Clazz&quot;&gt; &lt;id property=&quot;cid&quot; column=&quot;cid&quot;/&gt; &lt;result property=&quot;cname&quot; column=&quot;cname&quot;/&gt; &lt;!--主要看这里--&gt; &lt;collection property=&quot;stus&quot; select=&quot;com.powernode.mybatis.mapper.StudentMapper.selectByCid&quot; column=&quot;cid&quot;/&gt;&lt;/resultMap&gt;&lt;!--sql语句也变化了--&gt;&lt;select id=&quot;selectClazzAndStusByCid&quot; resultMap=&quot;clazzResultMap&quot;&gt; select * from t_clazz c where c.cid = #&#123;cid&#125;&lt;/select&gt; 1234567/*** 根据班级编号获取所有的学生。* @param cid* @return*/List&lt;Student&gt; selectByCid(Integer cid); 123&lt;select id=&quot;selectByCid&quot; resultType=&quot;Student&quot;&gt; select * from t_student where cid = #&#123;cid&#125;&lt;/select&gt; 执行结果： 13.4 一对多延迟加载一对多延迟加载机制和多对一是一样的。同样是通过两种方式： 第一种：fetchType&#x3D;”lazy” 第二种：修改全局的配置setting，lazyLoadingEnabled&#x3D;true，如果开启全局延迟加载，想让某个sql不使用延迟加载：fetchType&#x3D;”eager” 十四、MyBatis的缓存缓存：cache 缓存的作用：通过减少IO的方式，来提高程序的执行效率。 mybatis的缓存：将select语句的查询结果放到缓存（内存）当中，下一次还是这条select语句的话，直接从缓存中取，不再查数据库。一方面是减少了IO。另一方面不再执行繁琐的查找算法。效率大大提升。 mybatis缓存包括： 一级缓存：将查询到的数据存储到SqlSession中。 二级缓存：将查询到的数据存储到SqlSessionFactory中。 或者集成其它第三方的缓存：比如EhCache【Java语言开发的】、Memcache【C语言开发的】等。 缓存只针对于DQL语句，也就是说缓存机制只对应select语句。 14.1 一级缓存一级缓存默认是开启的。不需要做任何配置。 原理：只要使用同一个SqlSession对象执行同一条SQL语句，就会走缓存。 模块名：mybatis-010-cache 12345678910111213package com.powernode.mybatis.mapper;import com.powernode.mybatis.pojo.Car;public interface CarMapper &#123; /** * 根据id获取Car信息。 * @param id * @return */ Car selectById(Long id);&#125; 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.CarMapper&quot;&gt; &lt;select id=&quot;selectById&quot; resultType=&quot;Car&quot;&gt; select * from t_car where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.CarMapper;import com.powernode.mybatis.pojo.Car;import com.powernode.mybatis.utils.SqlSessionUtil;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;public class CarMapperTest &#123; @Test public void testSelectById() throws Exception&#123; // 注意：不能使用我们封装的SqlSessionUtil工具类。 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = builder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession1 = sqlSessionFactory.openSession(); CarMapper mapper1 = sqlSession1.getMapper(CarMapper.class); Car car1 = mapper1.selectById(83L); System.out.println(car1); CarMapper mapper2 = sqlSession1.getMapper(CarMapper.class); Car car2 = mapper2.selectById(83L); System.out.println(car2); SqlSession sqlSession2 = sqlSessionFactory.openSession(); CarMapper mapper3 = sqlSession2.getMapper(CarMapper.class); Car car3 = mapper3.selectById(83L); System.out.println(car3); CarMapper mapper4 = sqlSession2.getMapper(CarMapper.class); Car car4 = mapper4.selectById(83L); System.out.println(car4); &#125;&#125; 执行结果： 什么情况下不走缓存？ 第一种：不同的SqlSession对象。 第二种：查询条件变化了。 一级缓存失效情况包括两种： 第一种：第一次查询和第二次查询之间，手动清空了一级缓存。 1sqlSession.clearCache(); 第二种：第一次查询和第二次查询之间，执行了增删改操作。【这个增删改和哪张表没有关系，只要有insert delete update操作，一级缓存就失效。】 1234567/*** 保存账户信息*/void insertAccount();&lt;insert id=&quot;insertAccount&quot;&gt; insert into t_act values(3, &#x27;act003&#x27;, 10000)&lt;/insert&gt; 执行结果： 14.2 二级缓存二级缓存的范围是SqlSessionFactory。 使用二级缓存需要具备以下几个条件： 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。默认就是true，无需设置。 在需要使用二级缓存的SqlMapper.xml文件中添加配置： 使用二级缓存的实体类对象必须是可序列化的，也就是必须实现java.io.Serializable接口 SqlSession对象关闭或提交之后，一级缓存中的数据才会被写入到二级缓存当中。此时二级缓存才可用。 测试二级缓存： 1&lt;cache/&gt; 123456789101112131415161718192021public class Car implements Serializable &#123;//......&#125;@Testpublic void testSelectById2() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession1 = sqlSessionFactory.openSession(); CarMapper mapper1 = sqlSession1.getMapper(CarMapper.class); Car car1 = mapper1.selectById(83L); System.out.println(car1); // 关键一步 sqlSession1.close(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); CarMapper mapper2 = sqlSession2.getMapper(CarMapper.class); Car car2 = mapper2.selectById(83L); System.out.println(car2);&#125; 二级缓存的失效：只要两次查询之间出现了增删改操作。二级缓存就会失效。【一级缓存也会失效】 二级缓存的相关配置： eviction：指定从缓存中移除某个对象的淘汰算法。默认采用LRU策略。 LRU：Least Recently Used。最近最少使用。优先淘汰在间隔时间内使用频率最低的对象。(其实还有一种淘汰算法LFU，最不常用。) FIFO：First In First Out。一种先进先出的数据缓存器。先进入二级缓存的对象最先被淘汰。 SOFT：软引用。淘汰软引用指向的对象。具体算法和JVM的垃圾回收算法有关。 WEAK：弱引用。淘汰弱引用指向的对象。具体算法和JVM的垃圾回收算法有关。 flushInterval： 二级缓存的刷新时间间隔。单位毫秒。如果没有设置。就代表不刷新缓存，只要内存足够大，一直会向二级缓存中缓存数据。除非执行了增删改。 readOnly： true：多条相同的sql语句执行之后返回的对象是共享的同一个。性能好。但是多线程并发可能会存在安全问题。 false：多条相同的sql语句执行之后返回的对象是副本，调用了clone方法。性能一般。但安全。 size： 设置二级缓存中最多可存储的java对象数量。默认值1024。 14.3 MyBatis集成EhCache集成EhCache是为了代替mybatis自带的二级缓存。一级缓存是无法替代的。 mybatis对外提供了接口，也可以集成第三方的缓存组件。比如EhCache、Memcache等。都可以。 EhCache是Java写的。Memcache是C语言写的。所以mybatis集成EhCache较为常见，按照以下步骤操作，就可以完成集成： 第一步：引入mybatis整合ehcache的依赖。 123456&lt;!--mybatis集成ehcache的组件--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt; 第二步：在类的根路径下新建echcache.xml文件，并提供以下配置信息。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;!--磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存--&gt; &lt;diskStore path=&quot;e:/ehcache&quot;/&gt; &lt;!--defaultCache：默认的管理策略--&gt; &lt;!--eternal：设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断--&gt; &lt;!--maxElementsInMemory：在内存中缓存的element的最大数目--&gt; &lt;!--overflowToDisk：如果内存中数据超过内存限制，是否要缓存到磁盘上--&gt; &lt;!--diskPersistent：是否在磁盘上持久化。指重启jvm后，数据是否有效。默认为false--&gt; &lt;!--timeToIdleSeconds：对象空闲时间(单位：秒)，指对象在多长时间没有被访问就会失效。只对eternal为false的有效。默认值0，表示一直可以访问--&gt; &lt;!--timeToLiveSeconds：对象存活时间(单位：秒)，指对象从创建到失效所需要的时间。只对eternal为false的有效。默认值0，表示一直可以访问--&gt; &lt;!--memoryStoreEvictionPolicy：缓存的3 种清空策略--&gt; &lt;!--FIFO：first in first out (先进先出)--&gt; &lt;!--LFU：Less Frequently Used (最少使用).意思是一直以来最少被使用的。缓存的元素有一个hit 属性，hit 值最小的将会被清出缓存--&gt; &lt;!--LRU：Least Recently Used(最近最少使用). (ehcache 默认值).缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存--&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;1000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;0&quot; timeToLiveSeconds=&quot;600&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;&lt;/ehcache&gt; 第三步：修改SqlMapper.xml文件中的标签，添加type属性。 1&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; 第四步：编写测试程序使用。 12345678910111213141516@Testpublic void testSelectById2() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession1 = sqlSessionFactory.openSession(); CarMapper mapper1 = sqlSession1.getMapper(CarMapper.class); Car car1 = mapper1.selectById(83L); System.out.println(car1); sqlSession1.close(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); CarMapper mapper2 = sqlSession2.getMapper(CarMapper.class); Car car2 = mapper2.selectById(83L); System.out.println(car2);&#125; 十五、MyBatis的逆向工程所谓的逆向工程是：根据数据库表逆向生成Java的pojo类，SqlMapper.xml文件，以及Mapper接口类等。 要完成这个工作，需要借助别人写好的逆向工程插件。 思考：使用这个插件的话，需要给这个插件配置哪些信息？ pojo类名、包名以及生成位置。 SqlMapper.xml文件名以及生成位置。 Mapper接口名以及生成位置。 连接数据库的信息。 指定哪些表参与逆向工程。 …… 15.1 逆向工程配置与生成第一步：基础环境准备新建模块：mybatis-011-generator 打包方式：jar 第二步：在pom中添加逆向工程插件1234567891011121314151617181920212223242526&lt;!--定制构建过程--&gt;&lt;build&gt; &lt;!--可配置多个插件--&gt; &lt;plugins&gt; &lt;!--其中的一个插件：mybatis逆向工程插件--&gt; &lt;plugin&gt; &lt;!--插件的GAV坐标--&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;!--允许覆盖--&gt; &lt;configuration&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;!--插件的依赖--&gt; &lt;dependencies&gt; &lt;!--mysql驱动依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 第三步：配置generatorConfig.xml该文件名必须叫做：generatorConfig.xml 该文件必须放在类的根路径下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime有两个值： MyBatis3Simple：生成的是基础版，只有基本的增删改查。 MyBatis3：生成的是增强版，除了基本的增删改查之外还有复杂的增删改查。 --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!--防止生成重复代码--&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot;/&gt; &lt;commentGenerator&gt; &lt;!--是否去掉生成日期--&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!--是否去除注释--&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--连接数据库信息--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/powernode&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 生成pojo包名和位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.powernode.mybatis.pojo&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!--是否开启子包--&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;!--是否去除字段名的前后空白--&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成SQL映射文件的包名和位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.powernode.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;!--是否开启子包--&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成Mapper接口的包名和位置 --&gt; &lt;javaClientGenerator type=&quot;xmlMapper&quot; targetPackage=&quot;com.powernode.mybatis.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 表名和对应的实体类名--&gt; &lt;table tableName=&quot;t_car&quot; domainObjectName=&quot;Car&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 第四步：运行插件 15.2 测试逆向工程生成的是否好用第一步：环境准备 依赖：mybatis依赖、mysql驱动依赖、junit依赖、logback依赖 jdbc.properties mybatis-config.xml logback.xml 第二步：编写测试程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.CarMapper;import com.powernode.mybatis.pojo.Car;import com.powernode.mybatis.pojo.CarExample;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.math.BigDecimal;import java.util.List;public class GeneratorTest &#123; @Test public void testGenerator() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); CarMapper mapper = sqlSession.getMapper(CarMapper.class); // 增 /*Car car = new Car(); car.setCarNum(&quot;1111&quot;); car.setBrand(&quot;比亚迪唐&quot;); car.setGuidePrice(new BigDecimal(30.0)); car.setProduceTime(&quot;2010-10-12&quot;); car.setCarType(&quot;燃油车&quot;); int count = mapper.insert(car); System.out.println(&quot;插入了几条记录：&quot; + count);*/ // 删 /*int count = mapper.deleteByPrimaryKey(83L); System.out.println(&quot;删除了几条记录：&quot; + count);*/ // 改 // 根据主键修改 /*Car car = new Car(); car.setId(89L); car.setGuidePrice(new BigDecimal(20.0)); car.setCarType(&quot;新能源&quot;); int count = mapper.updateByPrimaryKey(car); System.out.println(&quot;更新了几条记录：&quot; + count);*/ // 根据主键选择性修改 /*car = new Car(); car.setId(89L); car.setCarNum(&quot;3333&quot;); car.setBrand(&quot;宝马520Li&quot;); car.setProduceTime(&quot;1999-01-10&quot;); count = mapper.updateByPrimaryKeySelective(car); System.out.println(&quot;更新了几条记录：&quot; + count);*/ // 查一个 Car car = mapper.selectByPrimaryKey(89L); System.out.println(car); // 查所有 List&lt;Car&gt; cars = mapper.selectByExample(null); cars.forEach(c -&gt; System.out.println(c)); // 多条件查询 // QBC 风格：Query By Criteria 一种查询方式，比较面向对象，看不到sql语句。 CarExample carExample = new CarExample(); carExample.createCriteria() .andBrandEqualTo(&quot;丰田霸道&quot;) .andGuidePriceGreaterThan(new BigDecimal(60.0)); carExample.or().andProduceTimeBetween(&quot;2000-10-11&quot;, &quot;2022-10-11&quot;); mapper.selectByExample(carExample); sqlSession.commit(); &#125;&#125; 十六、MyBatis使用PageHelper16.1 limit分页 mysql的limit后面两个数字： 第一个数字：startIndex（起始下标。下标从0开始。） 第二个数字：pageSize（每页显示的记录条数） 假设已知页码pageNum，还有每页显示的记录条数pageSize，第一个数字可以动态的获取吗？ startIndex &#x3D; (pageNum - 1) * pageSize 所以，标准通用的mysql分页SQL： 123456select * from tableName ...... limit (pageNum - 1) * pageSize, pageSize 使用mybatis应该怎么做？ 模块名：mybatis-012-page 1234567891011121314151617package com.powernode.mybatis.mapper;import com.powernode.mybatis.pojo.Car;import org.apache.ibatis.annotations.Param;import java.util.List;public interface CarMapper &#123; /** * 通过分页的方式获取Car列表 * @param startIndex 页码 * @param pageSize 每页显示记录条数 * @return */ List&lt;Car&gt; selectAllByPage(@Param(&quot;startIndex&quot;) Integer startIndex, @Param(&quot;pageSize&quot;) Integer pageSize);&#125; 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.mybatis.mapper.CarMapper&quot;&gt; &lt;select id=&quot;selectAllByPage&quot; resultType=&quot;Car&quot;&gt; select * from t_car limit #&#123;startIndex&#125;,#&#123;pageSize&#125; &lt;/select&gt;&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.CarMapper;import com.powernode.mybatis.pojo.Car;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.util.List;public class PageTest &#123; @Test public void testPage()throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); CarMapper mapper = sqlSession.getMapper(CarMapper.class); // 页码 Integer pageNum = 2; // 每页显示记录条数 Integer pageSize = 3; // 起始下标 Integer startIndex = (pageNum - 1) * pageSize; List&lt;Car&gt; cars = mapper.selectAllByPage(startIndex, pageSize); cars.forEach(car -&gt; System.out.println(car)); sqlSession.commit(); sqlSession.close(); &#125;&#125; 执行结果： 获取数据不难，难的是获取分页相关的数据比较难。有没有上一页，有没有下一页，可以分多少页等等，可以借助mybatis的PageHelper插件。 16.3 PageHelper插件使用PageHelper插件进行分页，更加的便捷。 第一步：引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt; 第二步：在mybatis-config.xml文件中配置插件typeAliases标签下面进行配置： 123&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;&lt;/plugins&gt; 第三步：编写Java代码1List&lt;Car&gt; selectAll(); 123&lt;select id=&quot;selectAll&quot; resultType=&quot;Car&quot;&gt; select * from t_car&lt;/select&gt; 关键点： 在查询语句之前开启分页功能。 在查询语句之后封装PageInfo对象。（PageInfo对象将来会存储到request域当中。在页面上展示。） 1234567891011121314151617@Testpublic void testPageHelper() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); CarMapper mapper = sqlSession.getMapper(CarMapper.class); // 开启分页 PageHelper.startPage(2, 2); // 执行查询语句 List&lt;Car&gt; cars = mapper.selectAll(); // 获取分页信息对象 PageInfo&lt;Car&gt; pageInfo = new PageInfo&lt;&gt;(cars, 5); System.out.println(pageInfo);&#125; 执行结果： PageInfo{pageNum&#x3D;2, pageSize&#x3D;2, size&#x3D;2, startRow&#x3D;3, endRow&#x3D;4, total&#x3D;6, pages&#x3D;3, list&#x3D;Page{count&#x3D;true, pageNum&#x3D;2, pageSize&#x3D;2, startRow&#x3D;2, endRow&#x3D;4, total&#x3D;6, pages&#x3D;3, reasonable&#x3D;false, pageSizeZero&#x3D;false}[Car{id&#x3D;86, carNum&#x3D;’1234’, brand&#x3D;’丰田霸道’, guidePrice&#x3D;50.5, produceTime&#x3D;’2020-10-11’, carType&#x3D;’燃油车’}, Car{id&#x3D;87, carNum&#x3D;’1234’, brand&#x3D;’丰田霸道’, guidePrice&#x3D;50.5, produceTime&#x3D;’2020-10-11’, carType&#x3D;’燃油车’}], prePage&#x3D;1, nextPage&#x3D;3, isFirstPage&#x3D;false, isLastPage&#x3D;false, hasPreviousPage&#x3D;true, hasNextPage&#x3D;true, navigatePages&#x3D;5, navigateFirstPage&#x3D;1, navigateLastPage&#x3D;3, navigatepageNums&#x3D;[1, 2, 3]} 对执行结果进行格式化： 12345678PageInfo&#123; pageNum=2, pageSize=2, size=2, startRow=3, endRow=4, total=6, pages=3, list=Page&#123;count=true, pageNum=2, pageSize=2, startRow=2, endRow=4, total=6, pages=3, reasonable=false, pageSizeZero=false&#125; [Car&#123;id=86, carNum=&#x27;1234&#x27;, brand=&#x27;丰田霸道&#x27;, guidePrice=50.5, produceTime=&#x27;2020-10-11&#x27;, carType=&#x27;燃油车&#x27;&#125;, Car&#123;id=87, carNum=&#x27;1234&#x27;, brand=&#x27;丰田霸道&#x27;, guidePrice=50.5, produceTime=&#x27;2020-10-11&#x27;, carType=&#x27;燃油车&#x27;&#125;], prePage=1, nextPage=3, isFirstPage=false, isLastPage=false, hasPreviousPage=true, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=3, navigatepageNums=[1, 2, 3]&#125; 十七、MyBatis的注解式开发mybatis中也提供了注解式开发方式，采用注解可以减少Sql映射文件的配置。 当然，使用注解式开发的话，sql语句是写在java程序中的，这种方式也会给sql语句的维护带来成本。 官方是这么说的： 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。 使用注解编写复杂的SQL是这样的： 原则：简单sql可以注解。复杂sql使用xml。 模块名：mybatis-013-annotation 打包方式：jar 依赖：mybatis，mysql驱动，junit，logback 配置文件：jdbc.properties、mybatis-config.xml、logback.xml pojo：com.powernode.mybatis.pojo.Car mapper接口：com.powernode.mybatis.mapper.CarMapper 17.1 @Insert123456789101112package com.powernode.mybatis.mapper;import com.powernode.mybatis.pojo.Car;import org.apache.ibatis.annotations.Insert;public interface CarMapper &#123; @Insert(value=&quot;insert into t_car values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;)&quot;) int insert(Car car);&#125; 1234567891011121314151617181920212223package com.powernode.mybatis.test;import com.powernode.mybatis.mapper.CarMapper;import com.powernode.mybatis.pojo.Car;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;public class AnnotationTest &#123; @Test public void testInsert() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); CarMapper mapper = sqlSession.getMapper(CarMapper.class); Car car = new Car(null, &quot;1112&quot;, &quot;卡罗拉&quot;, 30.0, &quot;2000-10-10&quot;, &quot;燃油车&quot;); int count = mapper.insert(car); System.out.println(&quot;插入了几条记录：&quot; + count); sqlSession.commit(); sqlSession.close(); &#125;&#125; 17.2 @Delete12345678910111213@Delete(&quot;delete from t_car where id = #&#123;id&#125;&quot;)int deleteById(Long id);---------------------------------------------------@Testpublic void testDelete() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); CarMapper mapper = sqlSession.getMapper(CarMapper.class); mapper.deleteById(89L); sqlSession.commit(); sqlSession.close();&#125; 17.3 @Update1234567891011121314@Update(&quot;update t_car set car_num=#&#123;carNum&#125;,brand=#&#123;brand&#125;,guide_price=#&#123;guidePrice&#125;,produce_time=#&#123;produceTime&#125;,car_type=#&#123;carType&#125; where id=#&#123;id&#125;&quot;)int update(Car car);------------------------------------------------------------------------------------@Testpublic void testUpdate() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); CarMapper mapper = sqlSession.getMapper(CarMapper.class); Car car = new Car(88L,&quot;1001&quot;, &quot;凯美瑞&quot;, 30.0,&quot;2000-11-11&quot;, &quot;新能源&quot;); mapper.update(car); sqlSession.commit(); sqlSession.close();&#125; 17.4 @Select1234567891011121314151617181920@Select(&quot;select * from t_car where id = #&#123;id&#125;&quot;)@Results(&#123; @Result(column = &quot;id&quot;, property = &quot;id&quot;, id = true), @Result(column = &quot;car_num&quot;, property = &quot;carNum&quot;), @Result(column = &quot;brand&quot;, property = &quot;brand&quot;), @Result(column = &quot;guide_price&quot;, property = &quot;guidePrice&quot;), @Result(column = &quot;produce_time&quot;, property = &quot;produceTime&quot;), @Result(column = &quot;car_type&quot;, property = &quot;carType&quot;)&#125;)Car selectById(Long id);-------------------------------------------------------------------------------------------------------@Testpublic void testSelectById() throws Exception&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)); SqlSession sqlSession = sqlSessionFactory.openSession(); CarMapper carMapper = sqlSession.getMapper(CarMapper.class); Car car = carMapper.selectById(88L); System.out.println(car);&#125; 执行结果：","tags":["JAVA"],"categories":["JAVA","框架"]},{"title":"mov2","path":"/2024/06/07/mov2/","content":"movie3mvoceasfjl;asdf","tags":["movie"],"categories":["movie"]},{"title":"mov1","path":"/2024/06/07/mov1/","content":"asdfasdfsadf ceshi movie","tags":["movie"],"categories":["movie"]},{"title":"mov","path":"/2024/06/07/mov/","content":"ceshi movie1 movie2","tags":["movie"],"categories":["movie"]},{"title":"movie2","path":"/2024/06/03/movie2/","content":"测试电影2观后感","tags":["movie"],"categories":["movie"]},{"title":"movie1","path":"/2024/06/03/movie1/","content":"这是测试电影专栏如何我爱电影","tags":["movie"],"categories":["movie"]},{"title":"mysql的使用","path":"/2024/05/28/mysql/","content":"Mysql的使用DML（data manipulation language）是数据操纵语言：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。 DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。 DCL（DataControlLanguage）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。 mysql的数据类型数值类型整数类型 类型 占用的存储空间 无符号数取值范围 有符号数取值范围 含义 TINYINT 1字节 0～2^8^-1 -2^7^~2^7^-1 非常小的整数 SMALLINT 2字节 0～2^16^-1 -2^15^~2^15^-1 小的整数 MEDIUMINT 3字节 0～2^24^-1 -2^23^~2^23^-1 中等的整数 INTINTEGER 4字节 0～2^32^-1 -2^31^~2^31^-1 标准的整数 BIGINT 8字节 0～2^64^-1 -2^63^~2^63^-1 大整数 在数据类型后加上UNSIGNED表示无符号数 浮点数类型 类型 占用的存储空间 绝对值最小非0值 绝对值最大值 含义 FLOAT 4字节 ±1.175494351E-38 ±3.402823466E+38 单精度浮点数 DOUBLE 8字节 ±2.2250738585072014E-308 ±1.7976931348623157E+308 双精度浮点数 FLOAT(M,D) M表示该小数最多包含的有效数字个数 D表示小数保留小数点后十进制数字的个数 定点数类型 类型 占用的存储空间 取值范围 DECIMAL(M,D) 取决于M,D 取决于M,D M,D对应的存储空间 组中包含的十进制位 占用存储空间大小 1 or 2 1 3 or 4 2 5 or 6 3 7 or 8 or 9 4 将M-D 划分为组 每隔9位划为一组 后不满9的自为一组 按上标计算得出占用空间 日期和时间类型 类型 占用的空间 取值范围 含义 YEAR 1字节 1901 ～ 2155 年份值 DATE 3字节 1000-01-01 ～ 9999-12-31 日期值 TIME 3字节 -838:59:59 ～ 838:59:59 时间值 DATETIME 8字节 1000-01-01 00:00:00 ～ 9999-12-31 23:59:59 日期和时间值 TIMESTAMP 4字节 1970-01-01 00:00:01 ～ 2038-01-19 03:14:07 时间戳 1s &#x3D; 1000ms &#x3D; 1000000us 保留的小数秒位数 额外需要的存储空间 0 0 字节 1 or 2 1 字节 3 or 4 2 字节 5 or 6 3 字节 日期格式化 符号 意义 YYYY 年份 MM 月份 DD 日 hh 时 mm 分 ss 秒 uuuuu 小数秒 字符串类型 类型 最大长度 存储空间要求 含义 CHAR(M) M个字符 M×W 字节 固定长度的字符串 VARCHAR(M) M个字符 L+1或L+2字节 可变长度的字符串 TINYTEXT 2^8^ - 1字节 L+1字节 非常小型的字符串 TEXT 2 ^16^ - 1 字节 L+2字节 小型的字符串 MEDIUMTEXT 2 ^32^ - 1 字节 L+3字节 中等大小的字符串 LONGTEXT 2 ^64^ - 1 字节 L+4字节 大型的字符串 M代表该数据最多能存储的字符数量，L代表实际向该类型的列中存放的字符串在特定字符集下占用的字节数目，W代表在特定字符集下编码一个字符最多需要的字节数 ENUM和SET类型ENUM(‘str1’,’str2’,’str3’) 从里面选择一个 SET(‘str1’,’str2’,’str3’) 从里面选择一个或多个数据 二进制类型BIT类型 类型 占用的空间（单位：字节） 含义 BIT(M) 近似为（M+7）&#x2F; 8 存储M个二进制位的值 M的取值范围位 1 ～ 64 BINARY(M) 与 VARBINARY(M)BINARY(M) 与 VARBINARY(M) 是用来存放字节的 M代表该类型中最多能存放的字节数量 CHAR VARCHAR用于存放字符的 BLOB类型TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOB用于存储可变长度的二进制数据，比如图片、音频、压缩文件。很像TEXT类型，不过BLOB类型用来存储字节的，而TEXT用于存储字符的 数据库的基本操作展示数据库1SHOW DATABASE; 创建数据库12CREATE DATABASE 数据库名;CREATE DATABASE IF NOT EXISTS 数据库名; #不存在则创建 使用数据库1USE 数据库名 删除数据库12DROP DATABASE 数据库名;DROP DATABASE IF EXISTS 数据库名; ##存在则删除 数据表的基本操作展示数据表1SHOW TABLES FROM 数据库名 创建表12345678910CREATE TABLE TABLENAME (\t列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性]) COMMENT &#x27;表的注释信息&#x27;;###########################CREATE TABLE IF NOT EXISTS 表名(\t各个列的数据信息...) 删除表123DROP TABLE 表1,表2,...,表n;DROP TABLE IF EXISTS 表名; 查看表结构12345DESCRIBE 表名;DESC 表名;EXPLAIN 表名;SHOW COLUMNS FROM 表名;SHOW FIELDS FROM 表名； 使用其它数据库中的表 直接使用 数据库名.表名 修改表1234567891011121314########修改表名################ALTER TABLE 旧表名 RENAME TO 新表名;RENAME TABLE 旧表名1 TO 新表名1， 旧表名2 TO 新表名2, ... , 旧表名n TO 新表名n ;########增加列#########ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性];ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性] FIRST;ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性] AFTER 指定列名;########删除列#########ALTER TABLE 表名 DROP COLUMN 列名;########修改列信息#####ALTER TABLE 表名 MODIFY 列名 数据类型 [列的新属性];ALTER TABLE 表名 CHANGE 旧列名 新列名 数据类型 [列的新属性];########多个修改操作#####ALTER TABLE 表名 DROP COLUMN 列名1,MODIFY 列名2 数据类型 [列的新属性]; 列的属性简单查询1select * from 表名 简单插入1insert into 表名(列名1, 列名2 ,..., 列名n) values (列1的值,列2的值,...,列n的值) 批量插入1insert into 表名(列名1, 列名2 ,..., 列名n) values (列1的值,列2的值,...,列n的值),(列1的值,列2的值,...,列n的值),(列1的值,列2的值,...,列n的值); 列的属性 属性名 属性值 DEFAULT 默认值 NOT NULL 不能为null PRIMARY KEY 主键 UNIQUE 唯一约束 FOREIGN KEY 外键 AUTO_INCREMENT 自动增长 ZEROFILL 填充0 1234567891011Create table student_info(\tnumber INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(5), sex ENUM (&#x27;1&#x27;,&#x27;2&#x27;) COMMENT ‘注释列，这是枚举’, id_number CHAR(18) UNIQUE, ####连接student_score表做外键 A依赖于B则A为父表B为子表 外键一般左为子右为父 CONSTRAINT FOREIGN KEY(number) REFERENCES student_score(number) #####UNIQUE第二种写法##### UNIQUE KEY uk_id_number (id_number)) ps:主键和UNIQUE约束都能保证某个列或者列组合的唯一性，但是一张表中只能定义一个主键，却可以有多个UNIQUE的约束，主键列不允许存放NULL，而UNIQUE约束的列可以存放NULL，且可以在多个记录中出现 查看表结构1DESC 表名 查询基本查询查询单个列 1SELECT 列名 FROM 表名; 列的别名 1SELECT 列名 [AS] 列的别名 FROM 表名; 查询多个列 1SELECT 列名1,...,列名n FROM 表名; 查询所有列 1SELECT * FROM 表名; 查询结果去重 1SELECT DISTINCT 列名1,...,列名n FROM 表名; 限制条数 1limit n; 排序 12SELECT 列名1,...,列名n FROM 表名 ORDER BY 列名1;##默认ASC 从小到大 条件查询比较运算符 运算符 描述 示例 &#x3D; 等于 a &#x3D; b &lt;&#x3D;&gt; null值安全等于 a &lt;&#x3D;&gt; b &lt;&gt; or !&#x3D; 不等于 a &lt;&gt; b &lt; 小于 a &lt; b &lt;&#x3D; 小于等于 a &lt;&#x3D; b &gt; 大于 a &gt; b &gt;&#x3D; 大于等于 a &gt;&#x3D; b between a and b a&lt; v &lt;b v between a and b not between 不满足 a&lt; v &lt;b v not between a and b 匹配运算符 运算符 示例 描述 IN a IN (b1,b2,…) a是b1,b2,…中的某一个 NOT IN a NOT IN (b1,b2, …) a不是b1,b2,…中的某一个 NULL运算符 运算符 示例 描述 IS NULL a IS NULL a的值是NULL IS NOT NULL a IS NOT NULL a的值不是NULL 通配符 运算符 示例 描述 LIKE a LIKE b a匹配b NOT LIKE a NOT LIKE b a不匹配b % 表示匹配一个或多个字符 _ 表示匹配一个字符 &#x2F; 表示转义字符 算术运算符 运算符 示例 描述 + a + b 加法 - a - b 减法 * a * b 乘法 &#x2F; a &#x2F; b 除法 DIV a DIV b 取商整数部分 % a % b 取余数 - -a 取负数 逻辑运算符 运算符 示例 表述 NOT （ ！） NOT a 对a取反 AND (&amp;&amp;) a AND b a b 同时为真就是真 OR (||) a OR b a b有个真就是真 XOR a XOR b a b中有且只有一个为真 才为真 函数字符串处理函数 名称 示例 结果 描述 LEFT LEFT(‘ABC123’,3) ABC 给定字符串从左边取指定长度的子串 RIGHT RIGHT(‘ABC123’,3) 123 给定字符串从右边取指定长度的子串 LENGTH LENGTH(‘ABC’) 3 给定字符串占用的字节数量 LOWER LOWER(‘ABC’) abc 给定字符串的小写形式 UPPER UPPER(‘abc’) ABC 给定字符串的大写形式 LTRIM LTRIM(‘ abc’) abc 去除字符串左边的空格 RTRIM RTRIM(‘abc ‘) abc 去除字符串右边的空格 SUBSTRING SUBSTRING(‘abc123’,2,3) bc1 给定字符串从指定位置截取指定长度的子串 CONCAT CONCAT(‘abc’,’123’,’xyz’) abc123xyz 拼接字符串 CHAR_LENGTH CHAT_LENGTH(‘狗哥’) 2 给定字符的字符数量 时间日期函数 名称 调用示例 示例结果 描述 NOW NOW() 2021-05-11 17:01:22 返回当前日期和时间 CURDATE CURDATE() 2021-05-11 返回当前日期 CURTIME CURTIME() 17:01:22 返回当前时间 DATE DATE(‘2021-05-11 17:01:22 ‘) 2021-05-11 返回给定日期和时间值的日期提取出来 DATE_ADD DATE_ADD(‘2021-05-11 03:00:00’, INTERVAL 2 DAY) 2021-05-13 03:00:00 将给定日期和时间加上给定的时间间隔 DATE_SUB DATE_SUB(‘2021-05-01 00:00:00’,INTERVAL 2 DAY) 2021-05-01’ 00:00:00 将给定日期和时间减去给定的时间间隔 DATEDIFF DATEDIFF(‘2021-05-01’ ‘2021-05-07’) -6 返回两个日期之间的天数（负数表示前一个参数的日期比后一个参数的日期小） DATE_FORMAT DATE_FORMAT(NOW(),’%m-%d-%Y’) 05-11-2021 用给定的格式显示日期和时间 YEAR YEAR(‘2021-05-11’) 2021 提取年份 MONTH MONTH(‘2021-05-11’) 05 提取月份 DAY DAY(‘2021-05-11’) 11 提取日 HOUR HOUR(‘2021-05-11 17:01:22’) 17 提取小时 MINUTE MINUTE(‘2021-05-11 17:01:22’) 01 提取分钟 SECOND SECOND(‘2021-05-11 17:01:22’) 22 提取秒 时间单位 时间单位 描述 MICROSECOND 毫秒 SENCOND 秒 MINUTE 分钟 HOUR 小时 DAY 天 WEEK 星期 MONTH 月 QUATRER 季度 YEAR 年 日期时间格式符 格式符 含义 %b 简写的月份（Jan、Feb、…） %D 带有英文后缀的月份中的日期（0th、1st….) %d 数字格式的月份中的日期（00、01、&#x2F;&#x2F;&#x2F;） %f 微秒（000000～999999） %H 24小时制的小时（00 ～ 24） %h 12小时制的小时 （00 ～ 12） %i 数值格式的分钟 （00 ～ 59） %M 月份名（January、February、…) %m 数值形式的月份（00 ～ 12） %p 上午或下午（AM代表上午、PM代表下午） %S 秒（00 ～ 59） %s 秒（00 ～ 59） %W 星期名（Sunday、。。。） %w 周内第几天（0&#x3D;星期天，1&#x3D;星期一， ，6&#x3D;星期六） %Y 4位数字形式的年（2019） %y 两位数字的年（19） 数值处理函数 名称 调用示例 示例结果 描述 ABS ABS(-1) 1 取绝对值 PI PI() 3.141593 返回圆周率 COS COS(PI()) -1 返回一个角度的余弦 SIN SIN(PI()&#x2F;2) 1 返回一个角度的正弦 TAN TAN(0) 0 返回一个角度的正切 POW POW(2,2) 4 返回某个数的指定次幂 SQRT SQRT(9) 3 返回一个数的平方根 MOD MOD(5,2) 1 返回除法的余数 RAND RAND() 0.7537623539136372 返回一个随机数 CEIL CEIL(2,3) 3 返回不小于给定值的最小整数 FLOOR FLOOR(2,3) 2 返回不大于给定值的最大整数 流程控制表达式和函数1234567891011121314151617181920212223CASE WHEN 表达式1 THEN 结果1 [WHEN 表达式2 THIEN 结果2] [WHEN 表达式3 THIEN 结果3]ELSE 默认结果 ENDCASE 待比较表达式 WHEN 表达式1 THEN 结果1 [WHEN 表达式2 THEN 结果2] [WHEN 表达式3 THEN 结果3][ELSE 默认结果] ENDIF(表达式1, 表达式2, 表达式3)###表达式1为ture时 返回值为表达式2，否则为表达式3IFNULL(表达式1, 表达式2)###表达式1为NULL时 返回值为表达式2 否则返回表达式1NULLIF(表达式1, 表达式2)###表达式1与表达式2的值是相同 函数值返回NULL 否则返回表达式1MAX(表达式) 返回最大值MIN(表达式) 返回最小值SUM(表达式)\t返回总和AVG(表达式)\t返回平均值COUNT(表达式)返回非null的数量 分组查询需求查询成绩表中数学和语文的平均分 select avg(score) from stu_score where sub &#x3D; ‘数学’ select avg(score) from stu_score where sub &#x3D; ‘语文’ 当课程过多时需要20条语句太麻烦了 因此引入分组查询，将表中的数据按照sub的值分为多个组，如语文组，数学组 语文组 学号 科目 成绩 20210203 语文 88 20210205 语文 90 数学组 学号 科目 成绩 20210203 数学 60 20210205 数学 66 select sub，avg(score) from stu_score where group by sub sub avg(score) 语文 89 数学 63 PS:通过where子句可以将数据在划分分组之前过滤掉 HAVING子句针对分组的过滤条件 与分组列相关的条件 （分组依靠的列叫做分组列。比如上面的就是sub列为分组列） select sub，avg(score) from stu_score where group by sub having sub &#x3D; ‘语文’ 与作用与分组的汇总函数有关的条件 HAVING子句不局限于只能放置在查询列表中的汇总函数，只要是针对这个分组进行统计的汇总函数都可以 比如（老师想查询最高分大于98的课程的平均分） SELECT sub avg(scoe) FROM stu_score GROUP BY sub HAVING MAX(score) &gt; 98 max(score)汇总函数并没有出现在查询列表中 但是仍然可以作为HAVING子句的一部分 多个分组列将分组划分为更小的分组 group by dep,maj dep学院 maj专业 计算机学院组 计算机科学与技术组 软件工程组 航天学院组 飞行器设计组 电子信息组 注意事项如果分组查询中含有NULL，那么NULL也会作为一个独立的分组存在。 group by 子句后也可以跟随表达式（但不能是汇总函数） group by concat(‘专业：’，major)； 查询语句的顺序1234567SELECT [DISTINCT]查询列表[FROM 表名][WHERE 布尔表达式][GROUP BY 分组列表][HAVING 分组过滤条件][ORDER BY 排序列表][LIMIT 偏移量，限制条件] 子查询概念子查询：第一个查询语句的结果作为第二个查询语句的条件，为书写方便，将两条语句合并为一句，所有的子查询必须用小括号扩起来 1SELECT (SELECT num FROM stu_info WHERE name = &#x27;狗哥&#x27;) AS 学号; 列子查询概念：子查询的结果集中并不是一个单独的值，而是一个列(num列，包含两个值，10001和1002），这个子查询称为列子查询 行子查询概念：子查询的结果集中最多只包含一条记录，而且这条记录中有超过一个列的数据（如果该条件记录只包含一个列的话，该子查询就成了标量子查询），那么这个子查询就可以称为行子查询 表子查询概念：如果子查询的结果集中包含多行多列，那么这个子查询也可以称为表子查询 不相关子查询和相关子查询不相关子查询概念：子查询可以独立运作并产生结果，之后再拿结果作为外层查询的条件去执行外层查询，这种查询称为不相关子查询 相关子查询概念：子查询的语句中引用外层查询的列，这样的话子查询就不能当作一个独立的语句去执行，这种子查询称为相关子查询 同一表的子查询概念：不只是在涉及多表查询的时候会用到，有时单表也会用到子查询 汇总函数是用来对分组进行数据统计的（如果没有GROUP BY语句，则意味着全表的记录都归属于同一个分组），不能放到WHERE子句中。 1SELECT * FROM stu_score WHERE sub = &#x27;mysql&#x27; AND score &gt; (SELECT AVG(score) FROM stu_score WHERE sub = &#x27;mysql&#x27;); 连接查询概念：将表1和表2的记录连起来组成新的更大的记录，这个查询过程称为连接查询 在没有过滤条件下两个表连接起来生成的结果集也被称为笛卡儿积 n*n条记录 内连接和外连接内连接概念：对于内连接的两个表，如果驱动表（确定的第一个需要查询的表）中的记录在被驱动表中找不到匹配的记录，则该记录不会加入到最后的结果集中。 外连接概念：对于外连接的两个表，即使驱动表中的记录在被驱动表中没有匹配的记录，也仍然需要加入到结果集中 左外连接：它会返回左表中的所有记录，即使右表中没有匹配的记录也会显示左表的数据，但右表中的数据只会显示满足连接条件的记录。 1SELECT * FROM t1 LEFT(OUTER) JOIN t2 ON 过滤条件 (where 过滤条件); 将放在LEFT JOIN 中左侧的表称为外表或者驱动表，右侧的称为内表或者被驱动表 右外连接：它会返回右表中的所有记录，即使左表中没有匹配的记录也会显示右表的数据，但左表中的数据只会显示满足连接条件的记录。 1SELECT * FROM t1 RIGHT(OUTER) JOIN t2 ON 过滤条件 (where 过滤条件); 将放在RIGHT JOIN 中左侧的表称为外表或者驱动表，右侧的称为内表或者被驱动表 内连接 123456SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 过滤条件] [where 过滤条件]###下式等价SELECT * FROM t1 JOIN t2;SELECT * FROM t1 INNER JOIN t2;SELECT * FROM t1 CROSS JOIN t2;SELECT * FROM t2,t2; 并集查询概念：每个查询语句都有其相应的结果集，我们可以将多个查询语句的结果集合合并起来，这样称为并集查询 单表的并集查询1SELECT m1,m2 FROM t1 WHERE m1&lt;2 UNION SELECT m1,m2 FROM t1 WHERE m1&gt;3; 涉及不同表的并集查询1SELECT m1 FROM t1 WHERE m1&lt;2 UNION SELECT m1 FROM t2 WHERE m1&gt;5; 包含或者去除重复的行1234###并集查询默认过滤掉结果中重复的记录###包含重复的行SELECT m1 FROM t1 WHERE m1&lt;2 UNION ALL SELECT m1 FROM t2 WHERE m1&gt;5; 数据的增删改插入数据123456789101112###插入一条完整记录INSERT INTO 表名 VALUES(列1的值，列2的值，。。。，列n的值);###自定义插入数据中列的顺序INSERT INTO 表名（列1，列n，。。。列2） VALUES(列1的值，列n的值，。。。，列2的值);###批量插入INSERT INTO 表名（列1，列n） VALUES (列1的值，列n的值),(列1的值，列n的值),(列1的值，列n的值),(列1的值，列n的值);###将查询的结果集插入表中INSERT INTO 表名（列1，列n）SELECT 列1，列n FROM 表名2 WHERE 查询条件;###INSRET IGNORE 在有唯一约束的条件下 我们不知道插入的值是否有是唯一的可使用该关键字，如果表中有则忽略该插入，没有则正常插入INSERT IGNORE INTO 表名（列1，列n，。。。列2） VALUES(列1的值，列n的值，。。。，列2的值);###INSERT ... ON DUPLICATE KEY UPDATE 与INSERT INGNORE作用一样,区别是如果存在则把 存在的进行修改INSERT INTO 表名（列1，列n） VALUES (列1的值，列n的值) ON DUPLICATE KEY UPDATE 列1=列1的值，列n=列n的值; 删除数据1DELETE FROM 表名 [WHERE 表达式] 更新数据1UPDATE 表名 SET 列1=值1,列2=值2,...,列n=值n [WHERE 表达式] 视图 视图（view）是一种虚拟存在的表，视图中的数据并不在数据库中实际存在，视图中的数据来自定义视图时select查询的表，并且视图是动态生成的。 通俗的讲：视图只保存了select的SQL逻辑，不保存查询结果。所以我们在创建视图时，主要工作就落在创建select查询语句上。 MySQL 视图是一个虚拟的表，它由一个 SQL 查询定义，并且不存储实际的数据。视图的数据来自于查询执行的结果，并且可以像表一样被查询、更新和删除。视图提供了一种简化复杂查询的方法，并且可以用来限制用户对数据库中特定数据的访问。 视图的定义保存在数据字典内，创建视图所基于的表称为“基表” 创建视图12CREATE VIEW 视图名 AS 查询语句CREATE VIEW stu_view AS SELECT * FROM stu where stu_id = 1; 使用视图视图相当于某个查询语句的别名，对视图进行查询时MYSQL服务器会帮我们将对视图查询语句转换为对底表的查询语句然后执行，虽然视图的底层原理是在执行语句时转换为对底层表的操作，但是在使用层面上我们可以把视图当作一个表去使用。使用视图的好处也是易见的，视图可以简化语句的书写避免每次都书写过长的语句，而且视图直观，不用考虑底层实现； 查看视图12###查看视图定义SHOW CREATE VIEW 视图名; 删除视图1DROP VIEW 视图名 存储程序存储程序又可以分为存储例程、触发器、事件这几种类型。其中，存储例程需要我们手动调用，触发器和事件都是MySQL服务器在特定条件下自己调用的，存储列程又分为存储函数和存储过程 用户自定义变量12SET @变量名 = 变量值#自定义变量在定义和调用时都应该加上@，系统变量不需要加上 存储函数定义函数 123456789101112CREATE FUNCTION 存储函数名称 ([参数列表]) #参数列表 【参数名 数据类型 ，参数名 数据类型】RETURNS 返回值类型 BEGIN 函数体内容END #BEGIN˙中可以包含一个或多个语句，每条语句以分号结尾#某求平均值CREATE FUNCTION avg_score (s VARCHAR(100))RETURNS DOUBLE BEGIN RETURN (SELECT AVG(score) FROM stu_score WHERE sub =s);END 调用存储函数 1SELECT avg_score (&#x27;mysql是怎样运行的&#x27;); 查看函数 1SHOW CREATE FUNCTION 函数名 删除函数 1DROP FUNCTION 函数名 函数体 在函数体中定义局部变量，在存储函数函数体中，DECLARE语句必须放到其它语句之前 1DECLARE 变量1，变量2，。。。 数据类型[DEFAULT 默认值] 用户自定义变量也可以在函数体中使用 123BEGIN SET $abc = 1;END 函数体中使用判断语句 12345678910BEGIN IF 表达式 THEN 语句列表\t[ELSEIF 表达式 THEN 语句列表] ...#多个ELSEIF语句 [ELSE 语句列表] END IF;END 函数体中使用循环语句 123456789101112131415161718192021222324BEGIN #循环语句1\tWHILE 表达式 DO 语句列表\tEND WHILE\t#循环语句2\t#先执行语句列表中的语句，再判断表达式是否为真，如果为真则退出循环，否则继续执行语句\tREPEAT 语句列表\tUNTIL 表达式 END REPEAT; #循环语句3\t#loop没有判断终止条件，可以在语句列表中使用return结束循环\t#如果仅仅只是结束循环不是用RETURN语句将函数返回则使用LEAVE语句\tLOOP 语句列表\tEND LOOP flag:LOOP 语句列表 LEAVE flag;\tEND LOOP flag;\t#flag相当于给LOOP语句打了名为flag的标记，执行LEAVE flag 时，程序会结束flag标记代表的循环语句END 存储过程存储函数和存储过程都是存储例程，都是都某些语句的一个封装。存储函数会给调用它的用户一个返回结果，但是存储过程没有返回值。 定义存储过程 1234CREATE PROCEDURE 存储过程名称([参数列表])BEGIN 需要执行的语句END 调用存储过程 1CALL 存储过程([参数列表]) 查看和删除存储哦过程 123456#查看创建了那些存储过程SHOW PROCEDURE STATUS [LIKE 存储过程名称]#查看某个存储过程具体语句SHOW CREATE PROCEDURE 存储过程名称#删除某个存储过程DROP PROCEDURE 存储过程名称 存储过程中的语句 包括变量的使用，判断，循环结构 存储过程的参数前缀 [IN | OUT | INOUT]参数名 数据类型 前缀 实际参数是否必须是变量 描述 IN 否 用于调用者向存储过程中传递数据，如果IN参数在存储过程中被修改，则调用者不可见 OUT 是 用于把存储过程运行过程中产生的数据赋值给OUT参数，存储过程执行结束后，调用者可以访问OUT参数 INOUT 是 综合IN和OUT的特点，既可以用于调用者向存储过程传递数据，也可以用于存放存储过程中产生的数据以供调用者使用 存储过程和存储程序的区别 存储函数在定义时需要显示使用RETURNS 语句标明返回的数据类型，而且在函数体中必须使用RETURN语句来显式指定返回的值，存储过程则不需要 存储函数不支持IN，OUT，INOUT的参数前缀；存储过程支持 存储函数只能返回一个值，存储过程可以通过设置多个OUT参数或者INOUT参数来返回多个结果 存储函数在执行过程中产生的结果集并不会被显示到客户端；存储过程在执行过程中产生的结果集会被显示到客户端； 存储函数直接以函数调用的形式进行调用；存储过程只能通过CALL语句来显式调用 游标在MySQL中，游标（Cursor）是一种数据库对象，用于从结果集中逐行获取数据。它常常在存储过程（Stored Procedures）和函数（Functions）中使用，以实现对查询结果集的操作。游标提供了一种遍历查询结果集的机制，允许程序逐行处理数据。游标其实就是用来标记结果集中我们正在访问的某一条记录。在初始状态下，游标标记结果集中的第一条记录 创建游标 1234567DECLARE 游标名称 CURSOR FOR 查询语句;CREATE PROCEDURE cursor_dome()BEGIN DECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1;END #如果在存储程序中也有声明局部变量的语句，则创建游标的语句一定要放在局部变量声明的后面 打开或关闭游标 123456789101112OPEN 游标名称CLOSE 游标名称CREATE PROCEDURE cursor_dome()BEGIN DECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1; OPEN t1_record; CLOSE t1_record;END 通过游标获取记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364FETCH 游标名 INTO 变量1，变量2，变量3,...,变量n#把当前游标对应记录的各列的值依次赋值给into后面的各个变量。CREATE PROCEDURE cursor_dome()BEGIN DECLARE mv INT;\tDECLARE nv CHAR(2);\tDECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1;\tOPEN t1_record;\tFETCH t1_record into mv,nv;\tSELECT mv,nv;\tCLOSE t1_record;END CALL cursor_demo -----------mv | nv1 | a-----------CREATE PROCEDURE cursor_dome()BEGIN DECLARE mv INT;\tDECLARE nv CHAR(2);\tDECLARE r_count INT;\tDECLARE i INT DEFAULT 0 DECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1;\tSELECT COUNT(*) FROM t1 INTO r_count; OPEN t1_record;\tWHILE i &lt; r_count DO FETCH t1_record into mv,nv; SELECT mv,nv; SET i = i+1;\tEND WHILE;\tCLOSE t1_record;END #在遇到FETCH语句获取不到记录的时候,默认会停止存储函数或存储过程的执行，并且回返一个错误。在遇到这种情况可以采用下面语句DECLARE CONTINUE HANDLER FOR NOT FOUND 处理语句#处理语句可以是简单的一条语句，也可以是 BEGIN...END 包裹的多条语句，只要我们在存储过程或存储函数中写了这个语句，那么在FETCH语句获取不到记录的时候，服务器就会执行这里填写的处理语句CREATE PROCEDURE cursor_dome()BEGIN DECLARE mv INT;\tDECLARE nv CHAR(2);\tDECLARE done INT DEFAULT 0 DECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1;\tDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; OPEN t1_record; flag:LOOP FETCH t1_record INTO mv,nv; IF done = 1 THEN LEAVE flag; END IF; SELECT mv,nv,done;\tEND LOOP flag;\tCLOSE t1_record;END 触发器触发器是一种特殊的存储过程。触发器可以实现数据约束，数据验证，数据复制等功能。 应用环境：当对表中的记录进行增、删、改操作的前和后，都可能需要让MYSQL服务器自动执行一些额外的语句 创建触发器 12345678910CREATE TRIGGER 触发器名称&#123;BEFORE|AFTER&#125;&#123;INSERT|DELETE|UPDATE&#125;ON 表名FOR EACH ROWBEGIN\t触发器内容END#由大括号&#123;&#125;包裹并且内部用｜分隔的语句表示必须在给定的选项中选取一个值，比如&#123;BEFORE|AFTER&#125;表示必须在BEFORE、AFTER这两个之间选取一个 名称 描述 BEFORE 表示在具体的语句执行之前就开始执行触发器的内容 AFTER 表示在具体的语句执行之后才开始执行触发器的内容 {INSERT|DELETE|UPDATE}表示对那种语句设置触发器。MYSQL目前只支持对INSERT、DELETE、UPDATE这3种语句设置触发器 FOR EACH ROW BEGIN … END 表示对具体语句影响的每一条记录都执行我们自定义的触发器内容： 对于INSERT语句来说，FOR EACH ROW影响的记录就是我们准备插入的那些新记录； 对于DELETE语句和UPDATE语句来说，FOR EACH ROW影响的记录就是符合WHERE条件的那些记录（如果语句中没有WHERE条件，则代表全部的记录） 如果触发器内容只包含一条语句，则可以省略BEGN、END这两个词 MYSQL服务器会对某条语句影响的所有记录依次调用我们自定义的触发器内容，所以针对每一条受影响的记录我们需要一种方式来访问记录中的内容，MySQL提供NEW和OLD这两个单词分别代表新记录和旧记录，它们在不同语句中的含义不同： 对于INSERT语句设置的触发器来说，NEW代表准备插入的记录，OLD无效 对于DELETE语句设置的触发器来说，OLD代表删除前的记录，NEW无效 对于UPDATE语句设置的触发器来说，NEW代表修改后的记录，OLD代表修改前的记录 1234567891011121314151617CREATE TRIGGER bi_t1BEFORE INSERT ON t1FOR EACH ROWBEGIN\tIF NEW.m1&lt;1 THEN SET NEW.m1 = 1;\tELSEIF NEW.m1 &gt; 10 THEN SET NEW.m1 = 10;\tEND IF;END#NEW.列名表示当前插入记录指定列的值#bi是before insert首字母缩写INSERT INTO t1(m1,n1) VALUES(5,&#x27;e&#x27;),(100,&#x27;z&#x27;);#向t1表插入2条记录：(5,&#x27;e&#x27;),(100,&#x27;z&#x27;).在实际插入前都会执行一下触发器内容：#对于记录(5,&#x27;e&#x27;)来说，由于m1列的值是5，在1和10之间，所以可以顺利地插入到表中；#对于记录(100,&#x27;z&#x27;)来说，由于m1列的值是100，大于10，所以最终插入到表中的记录变成了(10,&#x27;z&#x27;) 查看和删除触发器 123456#查看当前数据库定义的所有触发器SHOW TRIGGERS;#查看某个具体的触发器的定义SHOW CREATE TRIGGER 触发器名#删除触发器DROP TRIGGER 触发器名 触发器使用注意事项 触发器内容中不能有输出结果集的语句 触发器内容中NEW代表记录的列的值可以被更改，OLD代表记录的列的值无法更改。NEW代表新插入或即将修改后的记录，修改它的列的值将影响INSERT和UPDATE语句执行后的结果，而OLD代表修改或删除之前的值，无法进行修改 在BEFORE触发器中，可以使用 ‘SET NEW.列名 &#x3D; 某个值‘ 的形式来更改待插入记录或者待更新记录的某个列的值，但是这种操作不能在AFTER触发器中使用，因为在执行AFTER触发器的内容时记录已经被插入完成或更新完成了 事件让MySQL服务器在某个时间点或者每隔一段时间自动地执行一些语句，这就需要取创建一个事件。 创建事件 12345678910CREATE EVENT 事件名ON SCHEDULE&#123;\tAT 某个确定的事件点;\tEVERY 期望的时间间隔 [STARTS 开始日期和时间][END 结束日期和时间]&#125;DOBEGIN\t具体的时间END 事件支持两个类型的自动执行方式：在某个确定的事件点执行；每隔一段时间执行一次。 在某个确定的事件点执行。 1234567CREATE EVENT insert_t1ON SCHEDULEAT &#x27;2021-09-01 15:00:00&#x27;;DOBEGIN\tINSERT INTO t1(m1,n1) VALUES(6,&#x27;f&#x27;);END 每隔一段时间执行一次 1234567CREATE EVENT insert_t1ON SCHEDULEEVERY 1 HOURDOBEGIN\tINSERT INTO t1(m1,n1) VALUES(6,&#x27;f&#x27;);END 指定该事件开始执行的日期和时间以及停止执行的日期和时间 12345678#该事件从&#x27;2021-09-01 15:00:00&#x27; 开始执行，直到 &#x27;2021-09-19 15:00:00&#x27;为止 每隔一个小时执行一次CREATE EVENT insert_t1ON SCHEDULEEVERY 1 HOUR STARTS &#x27;2021-09-01 15:00:00&#x27; ENDS &#x27;2021-09-19 15:00:00&#x27;DOBEGIN\tINSERT INTO t1(m1,n1) VALUES(6,&#x27;f&#x27;);END 查看或删除事件 123456#查看数据库中的所有事件SHOW EVENTS#查看某个具体的事件的定义SHOW CREATE EVENT 事件名#删除事件DROP EVENT 事件名 备份和恢复mysqldump1234567891011#备份指定数据库中的指定表mysqldump [其它选项] 数据库名 [表1名，表2名，...]mysqldump -uroot -p xiaohaizi stu_score &gt; stu_score.sql#备份指定数据库中的所有表mysqldump [其它选项] --databases 数据库1名，数据库2名，...mysqldump -uroot -p --databases xiaohaizi dahaizi#备份所有数据库的所有表mysqldump [其它选项] --all-databasesmysqldump -uroot -p --all-databases 使用SOURCE语句恢复数据1SOURCE C:\\stu_score.ssql 以文本形式导出1234567891011#导出数据SELECT ... INTO OUTFILE &#x27;文件路径&#x27; [导出选项]#常用导出选项FIELDS TERMINATED BY: 表示列分隔符，也就是各列的值之间使用什么符号进行分隔，默认以&#x27;\\t&#x27;分隔# FIELDS TERMINATED BY &#x27;,&#x27; 表示各列的值以逗号分隔FIELDS [OPTIONALLY] ENCLOSED BY: 表示列引用符，也就是每个列的值被什么符号包裹起来，默认是空字符串&#x27;&#x27;.如果加上 OPTIONALLY 则只会作用于字符串类型的列# FIELDS ENCLOSED BY &#x27; &quot; &#x27; 表示每个列的值都被双引号引起来LINES STARTING BY: 表示行开始符，也就是每一行以什么符号开头，默认是空字符串&#x27;&#x27;# LINES STARTING BY &#x27;%%&#x27; 表示每行以%%开头LINES TERMINATED BY 示行结束符，也就是每一行以什么符号结束，默认是换行符&#x27; &#x27;# LINES TERMINATED BY &#x27;$$&#x27; 表示每行以$$结尾 以文本形式导入123LOAD DATA [LOCAL] INFILE &#x27;文件路径&#x27; INTO TABLE 表名 [导入选项]#LOAD DATA INFILE &#x27;C:/a/stu_score.txt&#x27; INTO TABLE stu_score 用户管理mysql中的用户都保存在mysql.user这张表中。 创建用户创建用户 用户名 主机名 – 指明客户端可以在哪些机器上启动（也可以填写IP地址），如果省略则默认值为’%’，表示该用户可以在任意主机上启动客户端 密码 – 如果省略则表示此用户暂不需要密码 修改密码1ALTER USER &#x27;用户名&#x27;@ &#x27;主机名&#x27; IDENTIFIED BY &#x27;新密码&#x27;; 删除用户1DROP USER &#x27;用户名&#x27;@ &#x27;主机名&#x27; 权限管理授予权限1234GRANT 权限名称ON 应用级别TO &#x27;用户名&#x27; @ &#x27;主机名&#x27;[WITH GRANT OPTION] 权限名称表 权限名称 描述 ALL [PRIVILEGES] 代表除了GRANT OPTION PROXY 以外的其它所有权限 ALTER 修改数据库、表结构的权限 ALTER ROUTINE 修改或删除存储例程的权限 CREATE 创建数据库和表的权限 CREATE ROLE 创建角色的权限 CREATE ROUTINE 创建存储例程的权限 CREATE TABLESPASE 创建、删除和修改表空间以及日志文件组的权限 CREATE TEMPORARY TABLES 创建临时表的权限 CREATE USER 创建、删除、重命名用户，以及移除用户权限的权限 CREATE VIEW 创建和修改视图的权限 DELETE 删除记录的权限 DROP 删除数据库、表和视图的权限 DROP ROLE 删除角色的权限 EVENT 使用事件的权限 EXECUTE 执行存储例程的权限 FILE 允许服务器读写文件的权限 GRANT OPTION 给其它账户授予或移除权限的权限 INDEX 创建或删除索引的权限 INSERT 插入记录的权限 LOCK TABLES 使用LOCK TABLES语句的权限 PROCESS 使用SHOW PROCESSLIST语句看到所有线程的权限 PROXY 使用用户代理的权限 REFERENCES 创建外键的权限 RELOAD 使用FLUSH语句的权限 REPLICATION CLIENT 查看主、从服务器的权限 REPLICATION SLAVE 从服务器可以从主服务器读取二进制日志事件的权限 SELECT 使用SELECT语句的权限 SHOW DATABASES 使用SHOW DATABASES语句的权限 SHOW VIEW 使用SHOW VIEW语句的权限 SHUTDOWN 使用mysqladmin shutdown的权限 SUPER 使用诸如CHANGE REPLICATION SOURCE TO、CHANGE MASTER TO 、KILL、PURGE BINARY LOGS 、SET GLOBAL 和mysql admin debug命令的管理员操作的权限 TRIGGER 使用触发器的权限 UPDATE 使用UPDATE语句的权限 USAGE 无权限 应用级别 权限 描述 * . * 代表全局级别。全局级别的权限作用于任何数据库下的任何对象（诸如表、视图等） 数据库名.* 代表数据库级别。数据库级别的权限作用于指定数据库下的任何对象 数据库名.表名 代表表级别。表级别的权限作用于表中的任何列 WITH GRANT IPTION 如果在使用GRANT 语句为某个用户授予权限时添加了WITH GRANT OPTION子句，则表示该用户可以将自己拥有的权限授予其他人 PS：root用户默认拥有最高权限，它可以把任何权限授予其它用户 查看权限123SHOW GRANTS 语句查看某个用户目前拥有什么权限SHOW GRANTS FOR &#x27;xiaohaizi&#x27;@ &#x27;localhost&#x27;; 移除权限123REVOKE 权限名称ON 应用级别FROM &#x27;用户名&#x27;@ &#x27;主机名&#x27; JDBC连接MYSQL服务器123456&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041public class JdbcService &#123; public static final String URL = &quot;jdbc:mysql://localhost:3306/code&quot;; public static final String DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;; public static final String USER = &quot;root&quot;; public static final String PASS = &quot;******&quot;; public static void main(String[] args) throws Exception &#123; //1.注册驱动类 Class.forName(JdbcService.DRIVER); //2.获取连接 Connection conn = DriverManager.getConnection(JdbcService.URL, JdbcService.USER, JdbcService.PASS); //3.生成Statement对象 Statement stmt = conn.createStatement(); //4.执行语句并获取结果集对象 ResultSet rs = stmt.executeQuery(&quot;select * from tb_user&quot;); System.out.println(rs); //5.处理结果集 while (rs.next()) &#123; int id = rs.getInt(&quot;id&quot;); String userName = rs.getString(&quot;user_name&quot;); String password = rs.getString(&quot;password&quot;); String name = rs.getString(&quot;name&quot;); String age = rs.getString(&quot;age&quot;); String email = rs.getString(&quot;email&quot;); StringBuilder sb = new StringBuilder() .append(&quot;id:&quot;).append(id).append(&quot;\\t&quot;) .append(&quot;userName:&quot;).append(userName).append(&quot;\\t&quot;) .append(&quot;password:&quot;).append(password).append(&quot;\\t&quot;) .append(&quot;name:&quot;).append(name).append(&quot;\\t&quot;) .append(&quot;age:&quot;).append(age).append(&quot;\\t&quot;) .append(&quot;email:&quot;).append(email).append(&quot; &quot;); System.out.println(sb); &#125; //6.关闭连接，释放资源 rs.close(); stmt.close(); conn.close(); &#125;&#125;","tags":["mysql"],"categories":["数据库","mysql"]},{"title":"收藏","path":"/bookmark/index.html","content":"…"},{"title":"探索胖怪的体验","path":"/explore/1.html","content":"…"},{"title":"探索","path":"/explore/index.html","content":"…"},{"title":"关于","path":"/about/index.html","content":"友链关于昵称简介 关于本站 本站没有任何推广和打赏链接，如果您觉得哪个作品不错，欢迎去对应的仓库点个赞，或者在对应的文章下面留言互动一下。 开源项目无任何盈利目的，只在工作闲暇时间进行维护，有相关需求请前往对应项目提 Issue 进行反馈，通过私人邮件询问开源项目问题可能得不到答复。"},{"title":"Page","path":"/page/index.html","content":"This is a page test."},{"title":"测试","path":"/wiki/movie/index.html","content":"豆瓣top观影指南 豆瓣top观影指南豆瓣top观影指南","tags":[null]},{"title":"友链","path":"/friends/index.html","content":"友链关于小伙伴们如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。 [2023-12] 友链失联了怎么办?添加友链后如果网站长期无法访问，可能会被取消友链！如果您的网站恢复了，可以在申请友链时创建的那条 issue 中评论告知。 朋友们近期的文章 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 我们需要有一定的有效互动： 先友后链：与博主有至少 半年 的有效互动，例如 issue 或者评论留言。 [2023-12] 友链申请条件变更说明降低了对商业广告的要求，可以有但是不能太多。提高了「有效互动」的定义：5次更改为半年。 我已满足全部条件，快告诉我如何交换友链！如果您没有满足上述条件，即时提交了申请也不会通过哦～第一步：新建 Issue新建 GitHub Issue 按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：打开 压缩图 上传自己的头像，将图片尺寸调整到 144px 后下载。将压缩后的图片上传到 去不图床 或者其它稳定的图床并使用此图片链接作为头像。第二步：添加友链并等待管理员审核请添加本站到您的友链中：1234title: xxxurl: https://xxx.comavatar: screenshot: 待管理员审核通过，添加了 active 标签后，回来刷新即可生效。如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客重新部署。"},{"title":"肖申克的救赎","path":"/wiki/movie/肖申克的救赎.html","content":"肖申克的救赎是一部讲述了。。。。。。 asdfkjsadflkjaskdfljsadfasdfsadfasdf 阿斯顿发 阿斯顿发as sdaf 阿瑟费的 阿斯顿发生地方","tags":[null]},{"title":"朋友文章","path":"/friends/rss/index.html","content":""},{"title":"风之谷","path":"/wiki/movie/风之谷.html","content":"风之谷风之谷 风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷风之谷 风之谷风之谷","tags":[null]}]