[{"title":"mysql的使用","path":"/2024/05/28/mysql/","content":"Mysql的使用DML（data manipulation language）是数据操纵语言：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。 DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。 DCL（DataControlLanguage）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。 mysql的数据类型数值类型整数类型 类型 占用的存储空间 无符号数取值范围 有符号数取值范围 含义 TINYINT 1字节 0～2^8^-1 -2^7^~2^7^-1 非常小的整数 SMALLINT 2字节 0～2^16^-1 -2^15^~2^15^-1 小的整数 MEDIUMINT 3字节 0～2^24^-1 -2^23^~2^23^-1 中等的整数 INTINTEGER 4字节 0～2^32^-1 -2^31^~2^31^-1 标准的整数 BIGINT 8字节 0～2^64^-1 -2^63^~2^63^-1 大整数 在数据类型后加上UNSIGNED表示无符号数 浮点数类型 类型 占用的存储空间 绝对值最小非0值 绝对值最大值 含义 FLOAT 4字节 ±1.175494351E-38 ±3.402823466E+38 单精度浮点数 DOUBLE 8字节 ±2.2250738585072014E-308 ±1.7976931348623157E+308 双精度浮点数 FLOAT(M,D) M表示该小数最多包含的有效数字个数 D表示小数保留小数点后十进制数字的个数 定点数类型 类型 占用的存储空间 取值范围 DECIMAL(M,D) 取决于M,D 取决于M,D M,D对应的存储空间 组中包含的十进制位 占用存储空间大小 1 or 2 1 3 or 4 2 5 or 6 3 7 or 8 or 9 4 将M-D 划分为组 每隔9位划为一组 后不满9的自为一组 按上标计算得出占用空间 日期和时间类型 类型 占用的空间 取值范围 含义 YEAR 1字节 1901 ～ 2155 年份值 DATE 3字节 1000-01-01 ～ 9999-12-31 日期值 TIME 3字节 -838:59:59 ～ 838:59:59 时间值 DATETIME 8字节 1000-01-01 00:00:00 ～ 9999-12-31 23:59:59 日期和时间值 TIMESTAMP 4字节 1970-01-01 00:00:01 ～ 2038-01-19 03:14:07 时间戳 1s &#x3D; 1000ms &#x3D; 1000000us 保留的小数秒位数 额外需要的存储空间 0 0 字节 1 or 2 1 字节 3 or 4 2 字节 5 or 6 3 字节 日期格式化 符号 意义 YYYY 年份 MM 月份 DD 日 hh 时 mm 分 ss 秒 uuuuu 小数秒 字符串类型 类型 最大长度 存储空间要求 含义 CHAR(M) M个字符 M×W 字节 固定长度的字符串 VARCHAR(M) M个字符 L+1或L+2字节 可变长度的字符串 TINYTEXT 2^8^ - 1字节 L+1字节 非常小型的字符串 TEXT 2 ^16^ - 1 字节 L+2字节 小型的字符串 MEDIUMTEXT 2 ^32^ - 1 字节 L+3字节 中等大小的字符串 LONGTEXT 2 ^64^ - 1 字节 L+4字节 大型的字符串 M代表该数据最多能存储的字符数量，L代表实际向该类型的列中存放的字符串在特定字符集下占用的字节数目，W代表在特定字符集下编码一个字符最多需要的字节数 ENUM和SET类型ENUM(‘str1’,’str2’,’str3’) 从里面选择一个 SET(‘str1’,’str2’,’str3’) 从里面选择一个或多个数据 二进制类型BIT类型 类型 占用的空间（单位：字节） 含义 BIT(M) 近似为（M+7）&#x2F; 8 存储M个二进制位的值 M的取值范围位 1 ～ 64 BINARY(M) 与 VARBINARY(M)BINARY(M) 与 VARBINARY(M) 是用来存放字节的 M代表该类型中最多能存放的字节数量 CHAR VARCHAR用于存放字符的 BLOB类型TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOB用于存储可变长度的二进制数据，比如图片、音频、压缩文件。很像TEXT类型，不过BLOB类型用来存储字节的，而TEXT用于存储字符的 数据库的基本操作展示数据库1SHOW DATABASE; 创建数据库12CREATE DATABASE 数据库名;CREATE DATABASE IF NOT EXISTS 数据库名; #不存在则创建 使用数据库1USE 数据库名 删除数据库12DROP DATABASE 数据库名;DROP DATABASE IF EXISTS 数据库名; ##存在则删除 数据表的基本操作展示数据表1SHOW TABLES FROM 数据库名 创建表12345678910CREATE TABLE TABLENAME (\t列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性]) COMMENT &#x27;表的注释信息&#x27;;###########################CREATE TABLE IF NOT EXISTS 表名(\t各个列的数据信息...) 删除表123DROP TABLE 表1,表2,...,表n;DROP TABLE IF EXISTS 表名; 查看表结构12345DESCRIBE 表名;DESC 表名;EXPLAIN 表名;SHOW COLUMNS FROM 表名;SHOW FIELDS FROM 表名； 使用其它数据库中的表 直接使用 数据库名.表名 修改表1234567891011121314########修改表名################ALTER TABLE 旧表名 RENAME TO 新表名;RENAME TABLE 旧表名1 TO 新表名1， 旧表名2 TO 新表名2, ... , 旧表名n TO 新表名n ;########增加列#########ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性];ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性] FIRST;ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性] AFTER 指定列名;########删除列#########ALTER TABLE 表名 DROP COLUMN 列名;########修改列信息#####ALTER TABLE 表名 MODIFY 列名 数据类型 [列的新属性];ALTER TABLE 表名 CHANGE 旧列名 新列名 数据类型 [列的新属性];########多个修改操作#####ALTER TABLE 表名 DROP COLUMN 列名1,MODIFY 列名2 数据类型 [列的新属性]; 列的属性简单查询1select * from 表名 简单插入1insert into 表名(列名1, 列名2 ,..., 列名n) values (列1的值,列2的值,...,列n的值) 批量插入1insert into 表名(列名1, 列名2 ,..., 列名n) values (列1的值,列2的值,...,列n的值),(列1的值,列2的值,...,列n的值),(列1的值,列2的值,...,列n的值); 列的属性 属性名 属性值 DEFAULT 默认值 NOT NULL 不能为null PRIMARY KEY 主键 UNIQUE 唯一约束 FOREIGN KEY 外键 AUTO_INCREMENT 自动增长 ZEROFILL 填充0 1234567891011Create table student_info(\tnumber INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(5), sex ENUM (&#x27;1&#x27;,&#x27;2&#x27;) COMMENT ‘注释列，这是枚举’, id_number CHAR(18) UNIQUE, ####连接student_score表做外键 A依赖于B则A为父表B为子表 外键一般左为子右为父 CONSTRAINT FOREIGN KEY(number) REFERENCES student_score(number) #####UNIQUE第二种写法##### UNIQUE KEY uk_id_number (id_number)) ps:主键和UNIQUE约束都能保证某个列或者列组合的唯一性，但是一张表中只能定义一个主键，却可以有多个UNIQUE的约束，主键列不允许存放NULL，而UNIQUE约束的列可以存放NULL，且可以在多个记录中出现 查看表结构1DESC 表名 查询基本查询查询单个列 1SELECT 列名 FROM 表名; 列的别名 1SELECT 列名 [AS] 列的别名 FROM 表名; 查询多个列 1SELECT 列名1,...,列名n FROM 表名; 查询所有列 1SELECT * FROM 表名; 查询结果去重 1SELECT DISTINCT 列名1,...,列名n FROM 表名; 限制条数 1limit n; 排序 12SELECT 列名1,...,列名n FROM 表名 ORDER BY 列名1;##默认ASC 从小到大 条件查询比较运算符 运算符 描述 示例 &#x3D; 等于 a &#x3D; b &lt;&#x3D;&gt; null值安全等于 a &lt;&#x3D;&gt; b &lt;&gt; or !&#x3D; 不等于 a &lt;&gt; b &lt; 小于 a &lt; b &lt;&#x3D; 小于等于 a &lt;&#x3D; b &gt; 大于 a &gt; b &gt;&#x3D; 大于等于 a &gt;&#x3D; b between a and b a&lt; v &lt;b v between a and b not between 不满足 a&lt; v &lt;b v not between a and b 匹配运算符 运算符 示例 描述 IN a IN (b1,b2,…) a是b1,b2,…中的某一个 NOT IN a NOT IN (b1,b2, …) a不是b1,b2,…中的某一个 NULL运算符 运算符 示例 描述 IS NULL a IS NULL a的值是NULL IS NOT NULL a IS NOT NULL a的值不是NULL 通配符 运算符 示例 描述 LIKE a LIKE b a匹配b NOT LIKE a NOT LIKE b a不匹配b % 表示匹配一个或多个字符 _ 表示匹配一个字符 &#x2F; 表示转义字符 算术运算符 运算符 示例 描述 + a + b 加法 - a - b 减法 * a * b 乘法 &#x2F; a &#x2F; b 除法 DIV a DIV b 取商整数部分 % a % b 取余数 - -a 取负数 逻辑运算符 运算符 示例 表述 NOT （ ！） NOT a 对a取反 AND (&amp;&amp;) a AND b a b 同时为真就是真 OR (||) a OR b a b有个真就是真 XOR a XOR b a b中有且只有一个为真 才为真 函数字符串处理函数 名称 示例 结果 描述 LEFT LEFT(‘ABC123’,3) ABC 给定字符串从左边取指定长度的子串 RIGHT RIGHT(‘ABC123’,3) 123 给定字符串从右边取指定长度的子串 LENGTH LENGTH(‘ABC’) 3 给定字符串占用的字节数量 LOWER LOWER(‘ABC’) abc 给定字符串的小写形式 UPPER UPPER(‘abc’) ABC 给定字符串的大写形式 LTRIM LTRIM(‘ abc’) abc 去除字符串左边的空格 RTRIM RTRIM(‘abc ‘) abc 去除字符串右边的空格 SUBSTRING SUBSTRING(‘abc123’,2,3) bc1 给定字符串从指定位置截取指定长度的子串 CONCAT CONCAT(‘abc’,’123’,’xyz’) abc123xyz 拼接字符串 CHAR_LENGTH CHAT_LENGTH(‘狗哥’) 2 给定字符的字符数量 时间日期函数 名称 调用示例 示例结果 描述 NOW NOW() 2021-05-11 17:01:22 返回当前日期和时间 CURDATE CURDATE() 2021-05-11 返回当前日期 CURTIME CURTIME() 17:01:22 返回当前时间 DATE DATE(‘2021-05-11 17:01:22 ‘) 2021-05-11 返回给定日期和时间值的日期提取出来 DATE_ADD DATE_ADD(‘2021-05-11 03:00:00’, INTERVAL 2 DAY) 2021-05-13 03:00:00 将给定日期和时间加上给定的时间间隔 DATE_SUB DATE_SUB(‘2021-05-01 00:00:00’,INTERVAL 2 DAY) 2021-05-01’ 00:00:00 将给定日期和时间减去给定的时间间隔 DATEDIFF DATEDIFF(‘2021-05-01’ ‘2021-05-07’) -6 返回两个日期之间的天数（负数表示前一个参数的日期比后一个参数的日期小） DATE_FORMAT DATE_FORMAT(NOW(),’%m-%d-%Y’) 05-11-2021 用给定的格式显示日期和时间 YEAR YEAR(‘2021-05-11’) 2021 提取年份 MONTH MONTH(‘2021-05-11’) 05 提取月份 DAY DAY(‘2021-05-11’) 11 提取日 HOUR HOUR(‘2021-05-11 17:01:22’) 17 提取小时 MINUTE MINUTE(‘2021-05-11 17:01:22’) 01 提取分钟 SECOND SECOND(‘2021-05-11 17:01:22’) 22 提取秒 时间单位 时间单位 描述 MICROSECOND 毫秒 SENCOND 秒 MINUTE 分钟 HOUR 小时 DAY 天 WEEK 星期 MONTH 月 QUATRER 季度 YEAR 年 日期时间格式符 格式符 含义 %b 简写的月份（Jan、Feb、…） %D 带有英文后缀的月份中的日期（0th、1st….) %d 数字格式的月份中的日期（00、01、&#x2F;&#x2F;&#x2F;） %f 微秒（000000～999999） %H 24小时制的小时（00 ～ 24） %h 12小时制的小时 （00 ～ 12） %i 数值格式的分钟 （00 ～ 59） %M 月份名（January、February、…) %m 数值形式的月份（00 ～ 12） %p 上午或下午（AM代表上午、PM代表下午） %S 秒（00 ～ 59） %s 秒（00 ～ 59） %W 星期名（Sunday、。。。） %w 周内第几天（0&#x3D;星期天，1&#x3D;星期一， ，6&#x3D;星期六） %Y 4位数字形式的年（2019） %y 两位数字的年（19） 数值处理函数 名称 调用示例 示例结果 描述 ABS ABS(-1) 1 取绝对值 PI PI() 3.141593 返回圆周率 COS COS(PI()) -1 返回一个角度的余弦 SIN SIN(PI()&#x2F;2) 1 返回一个角度的正弦 TAN TAN(0) 0 返回一个角度的正切 POW POW(2,2) 4 返回某个数的指定次幂 SQRT SQRT(9) 3 返回一个数的平方根 MOD MOD(5,2) 1 返回除法的余数 RAND RAND() 0.7537623539136372 返回一个随机数 CEIL CEIL(2,3) 3 返回不小于给定值的最小整数 FLOOR FLOOR(2,3) 2 返回不大于给定值的最大整数 流程控制表达式和函数1234567891011121314151617181920212223CASE WHEN 表达式1 THEN 结果1 [WHEN 表达式2 THIEN 结果2] [WHEN 表达式3 THIEN 结果3]ELSE 默认结果 ENDCASE 待比较表达式 WHEN 表达式1 THEN 结果1 [WHEN 表达式2 THEN 结果2] [WHEN 表达式3 THEN 结果3][ELSE 默认结果] ENDIF(表达式1, 表达式2, 表达式3)###表达式1为ture时 返回值为表达式2，否则为表达式3IFNULL(表达式1, 表达式2)###表达式1为NULL时 返回值为表达式2 否则返回表达式1NULLIF(表达式1, 表达式2)###表达式1与表达式2的值是相同 函数值返回NULL 否则返回表达式1MAX(表达式) 返回最大值MIN(表达式) 返回最小值SUM(表达式)\t返回总和AVG(表达式)\t返回平均值COUNT(表达式)返回非null的数量 分组查询需求查询成绩表中数学和语文的平均分 select avg(score) from stu_score where sub &#x3D; ‘数学’ select avg(score) from stu_score where sub &#x3D; ‘语文’ 当课程过多时需要20条语句太麻烦了 因此引入分组查询，将表中的数据按照sub的值分为多个组，如语文组，数学组 语文组 学号 科目 成绩 20210203 语文 88 20210205 语文 90 数学组 学号 科目 成绩 20210203 数学 60 20210205 数学 66 select sub，avg(score) from stu_score where group by sub sub avg(score) 语文 89 数学 63 PS:通过where子句可以将数据在划分分组之前过滤掉 HAVING子句针对分组的过滤条件 与分组列相关的条件 （分组依靠的列叫做分组列。比如上面的就是sub列为分组列） select sub，avg(score) from stu_score where group by sub having sub &#x3D; ‘语文’ 与作用与分组的汇总函数有关的条件 HAVING子句不局限于只能放置在查询列表中的汇总函数，只要是针对这个分组进行统计的汇总函数都可以 比如（老师想查询最高分大于98的课程的平均分） SELECT sub avg(scoe) FROM stu_score GROUP BY sub HAVING MAX(score) &gt; 98 max(score)汇总函数并没有出现在查询列表中 但是仍然可以作为HAVING子句的一部分 多个分组列将分组划分为更小的分组 group by dep,maj dep学院 maj专业 计算机学院组 计算机科学与技术组 软件工程组 航天学院组 飞行器设计组 电子信息组 注意事项如果分组查询中含有NULL，那么NULL也会作为一个独立的分组存在。 group by 子句后也可以跟随表达式（但不能是汇总函数） group by concat(‘专业：’，major)； 查询语句的顺序1234567SELECT [DISTINCT]查询列表[FROM 表名][WHERE 布尔表达式][GROUP BY 分组列表][HAVING 分组过滤条件][ORDER BY 排序列表][LIMIT 偏移量，限制条件] 子查询概念子查询：第一个查询语句的结果作为第二个查询语句的条件，为书写方便，将两条语句合并为一句，所有的子查询必须用小括号扩起来 1SELECT (SELECT num FROM stu_info WHERE name = &#x27;狗哥&#x27;) AS 学号; 列子查询概念：子查询的结果集中并不是一个单独的值，而是一个列(num列，包含两个值，10001和1002），这个子查询称为列子查询 行子查询概念：子查询的结果集中最多只包含一条记录，而且这条记录中有超过一个列的数据（如果该条件记录只包含一个列的话，该子查询就成了标量子查询），那么这个子查询就可以称为行子查询 表子查询概念：如果子查询的结果集中包含多行多列，那么这个子查询也可以称为表子查询 不相关子查询和相关子查询不相关子查询概念：子查询可以独立运作并产生结果，之后再拿结果作为外层查询的条件去执行外层查询，这种查询称为不相关子查询 相关子查询概念：子查询的语句中引用外层查询的列，这样的话子查询就不能当作一个独立的语句去执行，这种子查询称为相关子查询 同一表的子查询概念：不只是在涉及多表查询的时候会用到，有时单表也会用到子查询 汇总函数是用来对分组进行数据统计的（如果没有GROUP BY语句，则意味着全表的记录都归属于同一个分组），不能放到WHERE子句中。 1SELECT * FROM stu_score WHERE sub = &#x27;mysql&#x27; AND score &gt; (SELECT AVG(score) FROM stu_score WHERE sub = &#x27;mysql&#x27;); 连接查询概念：将表1和表2的记录连起来组成新的更大的记录，这个查询过程称为连接查询 在没有过滤条件下两个表连接起来生成的结果集也被称为笛卡儿积 n*n条记录 内连接和外连接内连接概念：对于内连接的两个表，如果驱动表（确定的第一个需要查询的表）中的记录在被驱动表中找不到匹配的记录，则该记录不会加入到最后的结果集中。 外连接概念：对于外连接的两个表，即使驱动表中的记录在被驱动表中没有匹配的记录，也仍然需要加入到结果集中 左外连接：它会返回左表中的所有记录，即使右表中没有匹配的记录也会显示左表的数据，但右表中的数据只会显示满足连接条件的记录。 1SELECT * FROM t1 LEFT(OUTER) JOIN t2 ON 过滤条件 (where 过滤条件); 将放在LEFT JOIN 中左侧的表称为外表或者驱动表，右侧的称为内表或者被驱动表 右外连接：它会返回右表中的所有记录，即使左表中没有匹配的记录也会显示右表的数据，但左表中的数据只会显示满足连接条件的记录。 1SELECT * FROM t1 RIGHT(OUTER) JOIN t2 ON 过滤条件 (where 过滤条件); 将放在RIGHT JOIN 中左侧的表称为外表或者驱动表，右侧的称为内表或者被驱动表 内连接 123456SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 过滤条件] [where 过滤条件]###下式等价SELECT * FROM t1 JOIN t2;SELECT * FROM t1 INNER JOIN t2;SELECT * FROM t1 CROSS JOIN t2;SELECT * FROM t2,t2; 并集查询概念：每个查询语句都有其相应的结果集，我们可以将多个查询语句的结果集合合并起来，这样称为并集查询 单表的并集查询1SELECT m1,m2 FROM t1 WHERE m1&lt;2 UNION SELECT m1,m2 FROM t1 WHERE m1&gt;3; 涉及不同表的并集查询1SELECT m1 FROM t1 WHERE m1&lt;2 UNION SELECT m1 FROM t2 WHERE m1&gt;5; 包含或者去除重复的行1234###并集查询默认过滤掉结果中重复的记录###包含重复的行SELECT m1 FROM t1 WHERE m1&lt;2 UNION ALL SELECT m1 FROM t2 WHERE m1&gt;5; 数据的增删改插入数据123456789101112###插入一条完整记录INSERT INTO 表名 VALUES(列1的值，列2的值，。。。，列n的值);###自定义插入数据中列的顺序INSERT INTO 表名（列1，列n，。。。列2） VALUES(列1的值，列n的值，。。。，列2的值);###批量插入INSERT INTO 表名（列1，列n） VALUES (列1的值，列n的值),(列1的值，列n的值),(列1的值，列n的值),(列1的值，列n的值);###将查询的结果集插入表中INSERT INTO 表名（列1，列n）SELECT 列1，列n FROM 表名2 WHERE 查询条件;###INSRET IGNORE 在有唯一约束的条件下 我们不知道插入的值是否有是唯一的可使用该关键字，如果表中有则忽略该插入，没有则正常插入INSERT IGNORE INTO 表名（列1，列n，。。。列2） VALUES(列1的值，列n的值，。。。，列2的值);###INSERT ... ON DUPLICATE KEY UPDATE 与INSERT INGNORE作用一样,区别是如果存在则把 存在的进行修改INSERT INTO 表名（列1，列n） VALUES (列1的值，列n的值) ON DUPLICATE KEY UPDATE 列1=列1的值，列n=列n的值; 删除数据1DELETE FROM 表名 [WHERE 表达式] 更新数据1UPDATE 表名 SET 列1=值1,列2=值2,...,列n=值n [WHERE 表达式] 视图 视图（view）是一种虚拟存在的表，视图中的数据并不在数据库中实际存在，视图中的数据来自定义视图时select查询的表，并且视图是动态生成的。 通俗的讲：视图只保存了select的SQL逻辑，不保存查询结果。所以我们在创建视图时，主要工作就落在创建select查询语句上。 MySQL 视图是一个虚拟的表，它由一个 SQL 查询定义，并且不存储实际的数据。视图的数据来自于查询执行的结果，并且可以像表一样被查询、更新和删除。视图提供了一种简化复杂查询的方法，并且可以用来限制用户对数据库中特定数据的访问。 视图的定义保存在数据字典内，创建视图所基于的表称为“基表” 创建视图12CREATE VIEW 视图名 AS 查询语句CREATE VIEW stu_view AS SELECT * FROM stu where stu_id = 1; 使用视图视图相当于某个查询语句的别名，对视图进行查询时MYSQL服务器会帮我们将对视图查询语句转换为对底表的查询语句然后执行，虽然视图的底层原理是在执行语句时转换为对底层表的操作，但是在使用层面上我们可以把视图当作一个表去使用。使用视图的好处也是易见的，视图可以简化语句的书写避免每次都书写过长的语句，而且视图直观，不用考虑底层实现； 查看视图12###查看视图定义SHOW CREATE VIEW 视图名; 删除视图1DROP VIEW 视图名 存储程序存储程序又可以分为存储例程、触发器、事件这几种类型。其中，存储例程需要我们手动调用，触发器和事件都是MySQL服务器在特定条件下自己调用的，存储列程又分为存储函数和存储过程 用户自定义变量12SET @变量名 = 变量值#自定义变量在定义和调用时都应该加上@，系统变量不需要加上 存储函数定义函数 123456789101112CREATE FUNCTION 存储函数名称 ([参数列表]) #参数列表 【参数名 数据类型 ，参数名 数据类型】RETURNS 返回值类型 BEGIN 函数体内容END #BEGIN˙中可以包含一个或多个语句，每条语句以分号结尾#某求平均值CREATE FUNCTION avg_score (s VARCHAR(100))RETURNS DOUBLE BEGIN RETURN (SELECT AVG(score) FROM stu_score WHERE sub =s);END 调用存储函数 1SELECT avg_score (&#x27;mysql是怎样运行的&#x27;); 查看函数 1SHOW CREATE FUNCTION 函数名 删除函数 1DROP FUNCTION 函数名 函数体 在函数体中定义局部变量，在存储函数函数体中，DECLARE语句必须放到其它语句之前 1DECLARE 变量1，变量2，。。。 数据类型[DEFAULT 默认值] 用户自定义变量也可以在函数体中使用 123BEGIN SET $abc = 1;END 函数体中使用判断语句 12345678910BEGIN IF 表达式 THEN 语句列表\t[ELSEIF 表达式 THEN 语句列表] ...#多个ELSEIF语句 [ELSE 语句列表] END IF;END 函数体中使用循环语句 123456789101112131415161718192021222324BEGIN #循环语句1\tWHILE 表达式 DO 语句列表\tEND WHILE\t#循环语句2\t#先执行语句列表中的语句，再判断表达式是否为真，如果为真则退出循环，否则继续执行语句\tREPEAT 语句列表\tUNTIL 表达式 END REPEAT; #循环语句3\t#loop没有判断终止条件，可以在语句列表中使用return结束循环\t#如果仅仅只是结束循环不是用RETURN语句将函数返回则使用LEAVE语句\tLOOP 语句列表\tEND LOOP flag:LOOP 语句列表 LEAVE flag;\tEND LOOP flag;\t#flag相当于给LOOP语句打了名为flag的标记，执行LEAVE flag 时，程序会结束flag标记代表的循环语句END 存储过程存储函数和存储过程都是存储例程，都是都某些语句的一个封装。存储函数会给调用它的用户一个返回结果，但是存储过程没有返回值。 定义存储过程 1234CREATE PROCEDURE 存储过程名称([参数列表])BEGIN 需要执行的语句END 调用存储过程 1CALL 存储过程([参数列表]) 查看和删除存储哦过程 123456#查看创建了那些存储过程SHOW PROCEDURE STATUS [LIKE 存储过程名称]#查看某个存储过程具体语句SHOW CREATE PROCEDURE 存储过程名称#删除某个存储过程DROP PROCEDURE 存储过程名称 存储过程中的语句 包括变量的使用，判断，循环结构 存储过程的参数前缀 [IN | OUT | INOUT]参数名 数据类型 前缀 实际参数是否必须是变量 描述 IN 否 用于调用者向存储过程中传递数据，如果IN参数在存储过程中被修改，则调用者不可见 OUT 是 用于把存储过程运行过程中产生的数据赋值给OUT参数，存储过程执行结束后，调用者可以访问OUT参数 INOUT 是 综合IN和OUT的特点，既可以用于调用者向存储过程传递数据，也可以用于存放存储过程中产生的数据以供调用者使用 存储过程和存储程序的区别 存储函数在定义时需要显示使用RETURNS 语句标明返回的数据类型，而且在函数体中必须使用RETURN语句来显式指定返回的值，存储过程则不需要 存储函数不支持IN，OUT，INOUT的参数前缀；存储过程支持 存储函数只能返回一个值，存储过程可以通过设置多个OUT参数或者INOUT参数来返回多个结果 存储函数在执行过程中产生的结果集并不会被显示到客户端；存储过程在执行过程中产生的结果集会被显示到客户端； 存储函数直接以函数调用的形式进行调用；存储过程只能通过CALL语句来显式调用 游标在MySQL中，游标（Cursor）是一种数据库对象，用于从结果集中逐行获取数据。它常常在存储过程（Stored Procedures）和函数（Functions）中使用，以实现对查询结果集的操作。游标提供了一种遍历查询结果集的机制，允许程序逐行处理数据。游标其实就是用来标记结果集中我们正在访问的某一条记录。在初始状态下，游标标记结果集中的第一条记录 创建游标 1234567DECLARE 游标名称 CURSOR FOR 查询语句;CREATE PROCEDURE cursor_dome()BEGIN DECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1;END #如果在存储程序中也有声明局部变量的语句，则创建游标的语句一定要放在局部变量声明的后面 打开或关闭游标 123456789101112OPEN 游标名称CLOSE 游标名称CREATE PROCEDURE cursor_dome()BEGIN DECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1; OPEN t1_record; CLOSE t1_record;END 通过游标获取记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364FETCH 游标名 INTO 变量1，变量2，变量3,...,变量n#把当前游标对应记录的各列的值依次赋值给into后面的各个变量。CREATE PROCEDURE cursor_dome()BEGIN DECLARE mv INT;\tDECLARE nv CHAR(2);\tDECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1;\tOPEN t1_record;\tFETCH t1_record into mv,nv;\tSELECT mv,nv;\tCLOSE t1_record;END CALL cursor_demo -----------mv | nv1 | a-----------CREATE PROCEDURE cursor_dome()BEGIN DECLARE mv INT;\tDECLARE nv CHAR(2);\tDECLARE r_count INT;\tDECLARE i INT DEFAULT 0 DECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1;\tSELECT COUNT(*) FROM t1 INTO r_count; OPEN t1_record;\tWHILE i &lt; r_count DO FETCH t1_record into mv,nv; SELECT mv,nv; SET i = i+1;\tEND WHILE;\tCLOSE t1_record;END #在遇到FETCH语句获取不到记录的时候,默认会停止存储函数或存储过程的执行，并且回返一个错误。在遇到这种情况可以采用下面语句DECLARE CONTINUE HANDLER FOR NOT FOUND 处理语句#处理语句可以是简单的一条语句，也可以是 BEGIN...END 包裹的多条语句，只要我们在存储过程或存储函数中写了这个语句，那么在FETCH语句获取不到记录的时候，服务器就会执行这里填写的处理语句CREATE PROCEDURE cursor_dome()BEGIN DECLARE mv INT;\tDECLARE nv CHAR(2);\tDECLARE done INT DEFAULT 0 DECLARE t1_record CURSOR FOR SELECT m1,n1 FROM t1;\tDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; OPEN t1_record; flag:LOOP FETCH t1_record INTO mv,nv; IF done = 1 THEN LEAVE flag; END IF; SELECT mv,nv,done;\tEND LOOP flag;\tCLOSE t1_record;END 触发器触发器是一种特殊的存储过程。触发器可以实现数据约束，数据验证，数据复制等功能。 应用环境：当对表中的记录进行增、删、改操作的前和后，都可能需要让MYSQL服务器自动执行一些额外的语句 创建触发器 12345678910CREATE TRIGGER 触发器名称&#123;BEFORE|AFTER&#125;&#123;INSERT|DELETE|UPDATE&#125;ON 表名FOR EACH ROWBEGIN\t触发器内容END#由大括号&#123;&#125;包裹并且内部用｜分隔的语句表示必须在给定的选项中选取一个值，比如&#123;BEFORE|AFTER&#125;表示必须在BEFORE、AFTER这两个之间选取一个 名称 描述 BEFORE 表示在具体的语句执行之前就开始执行触发器的内容 AFTER 表示在具体的语句执行之后才开始执行触发器的内容 {INSERT|DELETE|UPDATE}表示对那种语句设置触发器。MYSQL目前只支持对INSERT、DELETE、UPDATE这3种语句设置触发器 FOR EACH ROW BEGIN … END 表示对具体语句影响的每一条记录都执行我们自定义的触发器内容： 对于INSERT语句来说，FOR EACH ROW影响的记录就是我们准备插入的那些新记录； 对于DELETE语句和UPDATE语句来说，FOR EACH ROW影响的记录就是符合WHERE条件的那些记录（如果语句中没有WHERE条件，则代表全部的记录） 如果触发器内容只包含一条语句，则可以省略BEGN、END这两个词 MYSQL服务器会对某条语句影响的所有记录依次调用我们自定义的触发器内容，所以针对每一条受影响的记录我们需要一种方式来访问记录中的内容，MySQL提供NEW和OLD这两个单词分别代表新记录和旧记录，它们在不同语句中的含义不同： 对于INSERT语句设置的触发器来说，NEW代表准备插入的记录，OLD无效 对于DELETE语句设置的触发器来说，OLD代表删除前的记录，NEW无效 对于UPDATE语句设置的触发器来说，NEW代表修改后的记录，OLD代表修改前的记录 1234567891011121314151617CREATE TRIGGER bi_t1BEFORE INSERT ON t1FOR EACH ROWBEGIN\tIF NEW.m1&lt;1 THEN SET NEW.m1 = 1;\tELSEIF NEW.m1 &gt; 10 THEN SET NEW.m1 = 10;\tEND IF;END#NEW.列名表示当前插入记录指定列的值#bi是before insert首字母缩写INSERT INTO t1(m1,n1) VALUES(5,&#x27;e&#x27;),(100,&#x27;z&#x27;);#向t1表插入2条记录：(5,&#x27;e&#x27;),(100,&#x27;z&#x27;).在实际插入前都会执行一下触发器内容：#对于记录(5,&#x27;e&#x27;)来说，由于m1列的值是5，在1和10之间，所以可以顺利地插入到表中；#对于记录(100,&#x27;z&#x27;)来说，由于m1列的值是100，大于10，所以最终插入到表中的记录变成了(10,&#x27;z&#x27;) 查看和删除触发器 123456#查看当前数据库定义的所有触发器SHOW TRIGGERS;#查看某个具体的触发器的定义SHOW CREATE TRIGGER 触发器名#删除触发器DROP TRIGGER 触发器名 触发器使用注意事项 触发器内容中不能有输出结果集的语句 触发器内容中NEW代表记录的列的值可以被更改，OLD代表记录的列的值无法更改。NEW代表新插入或即将修改后的记录，修改它的列的值将影响INSERT和UPDATE语句执行后的结果，而OLD代表修改或删除之前的值，无法进行修改 在BEFORE触发器中，可以使用 ‘SET NEW.列名 &#x3D; 某个值‘ 的形式来更改待插入记录或者待更新记录的某个列的值，但是这种操作不能在AFTER触发器中使用，因为在执行AFTER触发器的内容时记录已经被插入完成或更新完成了 事件让MySQL服务器在某个时间点或者每隔一段时间自动地执行一些语句，这就需要取创建一个事件。 创建事件 12345678910CREATE EVENT 事件名ON SCHEDULE&#123;\tAT 某个确定的事件点;\tEVERY 期望的时间间隔 [STARTS 开始日期和时间][END 结束日期和时间]&#125;DOBEGIN\t具体的时间END 事件支持两个类型的自动执行方式：在某个确定的事件点执行；每隔一段时间执行一次。 在某个确定的事件点执行。 1234567CREATE EVENT insert_t1ON SCHEDULEAT &#x27;2021-09-01 15:00:00&#x27;;DOBEGIN\tINSERT INTO t1(m1,n1) VALUES(6,&#x27;f&#x27;);END 每隔一段时间执行一次 1234567CREATE EVENT insert_t1ON SCHEDULEEVERY 1 HOURDOBEGIN\tINSERT INTO t1(m1,n1) VALUES(6,&#x27;f&#x27;);END 指定该事件开始执行的日期和时间以及停止执行的日期和时间 12345678#该事件从&#x27;2021-09-01 15:00:00&#x27; 开始执行，直到 &#x27;2021-09-19 15:00:00&#x27;为止 每隔一个小时执行一次CREATE EVENT insert_t1ON SCHEDULEEVERY 1 HOUR STARTS &#x27;2021-09-01 15:00:00&#x27; ENDS &#x27;2021-09-19 15:00:00&#x27;DOBEGIN\tINSERT INTO t1(m1,n1) VALUES(6,&#x27;f&#x27;);END 查看或删除事件 123456#查看数据库中的所有事件SHOW EVENTS#查看某个具体的事件的定义SHOW CREATE EVENT 事件名#删除事件DROP EVENT 事件名 备份和恢复mysqldump1234567891011#备份指定数据库中的指定表mysqldump [其它选项] 数据库名 [表1名，表2名，...]mysqldump -uroot -p xiaohaizi stu_score &gt; stu_score.sql#备份指定数据库中的所有表mysqldump [其它选项] --databases 数据库1名，数据库2名，...mysqldump -uroot -p --databases xiaohaizi dahaizi#备份所有数据库的所有表mysqldump [其它选项] --all-databasesmysqldump -uroot -p --all-databases 使用SOURCE语句恢复数据1SOURCE C:\\stu_score.ssql 以文本形式导出1234567891011#导出数据SELECT ... INTO OUTFILE &#x27;文件路径&#x27; [导出选项]#常用导出选项FIELDS TERMINATED BY: 表示列分隔符，也就是各列的值之间使用什么符号进行分隔，默认以&#x27;\\t&#x27;分隔# FIELDS TERMINATED BY &#x27;,&#x27; 表示各列的值以逗号分隔FIELDS [OPTIONALLY] ENCLOSED BY: 表示列引用符，也就是每个列的值被什么符号包裹起来，默认是空字符串&#x27;&#x27;.如果加上 OPTIONALLY 则只会作用于字符串类型的列# FIELDS ENCLOSED BY &#x27; &quot; &#x27; 表示每个列的值都被双引号引起来LINES STARTING BY: 表示行开始符，也就是每一行以什么符号开头，默认是空字符串&#x27;&#x27;# LINES STARTING BY &#x27;%%&#x27; 表示每行以%%开头LINES TERMINATED BY 示行结束符，也就是每一行以什么符号结束，默认是换行符&#x27; &#x27;# LINES TERMINATED BY &#x27;$$&#x27; 表示每行以$$结尾 以文本形式导入123LOAD DATA [LOCAL] INFILE &#x27;文件路径&#x27; INTO TABLE 表名 [导入选项]#LOAD DATA INFILE &#x27;C:/a/stu_score.txt&#x27; INTO TABLE stu_score 用户管理mysql中的用户都保存在mysql.user这张表中。 创建用户创建用户 用户名 主机名 – 指明客户端可以在哪些机器上启动（也可以填写IP地址），如果省略则默认值为’%’，表示该用户可以在任意主机上启动客户端 密码 – 如果省略则表示此用户暂不需要密码 修改密码1ALTER USER &#x27;用户名&#x27;@ &#x27;主机名&#x27; IDENTIFIED BY &#x27;新密码&#x27;; 删除用户1DROP USER &#x27;用户名&#x27;@ &#x27;主机名&#x27; 权限管理授予权限1234GRANT 权限名称ON 应用级别TO &#x27;用户名&#x27; @ &#x27;主机名&#x27;[WITH GRANT OPTION] 权限名称表 权限名称 描述 ALL [PRIVILEGES] 代表除了GRANT OPTION PROXY 以外的其它所有权限 ALTER 修改数据库、表结构的权限 ALTER ROUTINE 修改或删除存储例程的权限 CREATE 创建数据库和表的权限 CREATE ROLE 创建角色的权限 CREATE ROUTINE 创建存储例程的权限 CREATE TABLESPASE 创建、删除和修改表空间以及日志文件组的权限 CREATE TEMPORARY TABLES 创建临时表的权限 CREATE USER 创建、删除、重命名用户，以及移除用户权限的权限 CREATE VIEW 创建和修改视图的权限 DELETE 删除记录的权限 DROP 删除数据库、表和视图的权限 DROP ROLE 删除角色的权限 EVENT 使用事件的权限 EXECUTE 执行存储例程的权限 FILE 允许服务器读写文件的权限 GRANT OPTION 给其它账户授予或移除权限的权限 INDEX 创建或删除索引的权限 INSERT 插入记录的权限 LOCK TABLES 使用LOCK TABLES语句的权限 PROCESS 使用SHOW PROCESSLIST语句看到所有线程的权限 PROXY 使用用户代理的权限 REFERENCES 创建外键的权限 RELOAD 使用FLUSH语句的权限 REPLICATION CLIENT 查看主、从服务器的权限 REPLICATION SLAVE 从服务器可以从主服务器读取二进制日志事件的权限 SELECT 使用SELECT语句的权限 SHOW DATABASES 使用SHOW DATABASES语句的权限 SHOW VIEW 使用SHOW VIEW语句的权限 SHUTDOWN 使用mysqladmin shutdown的权限 SUPER 使用诸如CHANGE REPLICATION SOURCE TO、CHANGE MASTER TO 、KILL、PURGE BINARY LOGS 、SET GLOBAL 和mysql admin debug命令的管理员操作的权限 TRIGGER 使用触发器的权限 UPDATE 使用UPDATE语句的权限 USAGE 无权限 应用级别 权限 描述 * . * 代表全局级别。全局级别的权限作用于任何数据库下的任何对象（诸如表、视图等） 数据库名.* 代表数据库级别。数据库级别的权限作用于指定数据库下的任何对象 数据库名.表名 代表表级别。表级别的权限作用于表中的任何列 WITH GRANT IPTION 如果在使用GRANT 语句为某个用户授予权限时添加了WITH GRANT OPTION子句，则表示该用户可以将自己拥有的权限授予其他人 PS：root用户默认拥有最高权限，它可以把任何权限授予其它用户 查看权限123SHOW GRANTS 语句查看某个用户目前拥有什么权限SHOW GRANTS FOR &#x27;xiaohaizi&#x27;@ &#x27;localhost&#x27;; 移除权限123REVOKE 权限名称ON 应用级别FROM &#x27;用户名&#x27;@ &#x27;主机名&#x27; JDBC连接MYSQL服务器123456&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041public class JdbcService &#123; public static final String URL = &quot;jdbc:mysql://localhost:3306/code&quot;; public static final String DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;; public static final String USER = &quot;root&quot;; public static final String PASS = &quot;******&quot;; public static void main(String[] args) throws Exception &#123; //1.注册驱动类 Class.forName(JdbcService.DRIVER); //2.获取连接 Connection conn = DriverManager.getConnection(JdbcService.URL, JdbcService.USER, JdbcService.PASS); //3.生成Statement对象 Statement stmt = conn.createStatement(); //4.执行语句并获取结果集对象 ResultSet rs = stmt.executeQuery(&quot;select * from tb_user&quot;); System.out.println(rs); //5.处理结果集 while (rs.next()) &#123; int id = rs.getInt(&quot;id&quot;); String userName = rs.getString(&quot;user_name&quot;); String password = rs.getString(&quot;password&quot;); String name = rs.getString(&quot;name&quot;); String age = rs.getString(&quot;age&quot;); String email = rs.getString(&quot;email&quot;); StringBuilder sb = new StringBuilder() .append(&quot;id:&quot;).append(id).append(&quot;\\t&quot;) .append(&quot;userName:&quot;).append(userName).append(&quot;\\t&quot;) .append(&quot;password:&quot;).append(password).append(&quot;\\t&quot;) .append(&quot;name:&quot;).append(name).append(&quot;\\t&quot;) .append(&quot;age:&quot;).append(age).append(&quot;\\t&quot;) .append(&quot;email:&quot;).append(email).append(&quot; &quot;); System.out.println(sb); &#125; //6.关闭连接，释放资源 rs.close(); stmt.close(); conn.close(); &#125;&#125;","tags":["mysql"],"categories":["数据库","mysql"]},{"title":"友链","path":"/friends/index.html","content":"友链关于小伙伴们如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。 [2023-12] 友链失联了怎么办?添加友链后如果网站长期无法访问，可能会被取消友链！如果您的网站恢复了，可以在申请友链时创建的那条 issue 中评论告知。 朋友们近期的文章 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 我们需要有一定的有效互动： 先友后链：与博主有至少 半年 的有效互动，例如 issue 或者评论留言。 [2023-12] 友链申请条件变更说明降低了对商业广告的要求，可以有但是不能太多。提高了「有效互动」的定义：5次更改为半年。 我已满足全部条件，快告诉我如何交换友链！如果您没有满足上述条件，即时提交了申请也不会通过哦～第一步：新建 Issue新建 GitHub Issue 按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：打开 压缩图 上传自己的头像，将图片尺寸调整到 144px 后下载。将压缩后的图片上传到 去不图床 或者其它稳定的图床并使用此图片链接作为头像。第二步：添加友链并等待管理员审核请添加本站到您的友链中：1234title: xxxurl: https://xxx.comavatar: screenshot: 待管理员审核通过，添加了 active 标签后，回来刷新即可生效。如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客重新部署。"},{"title":"探索","path":"/explore/index.html","content":"…"},{"title":"收藏","path":"/bookmark/index.html","content":"…"},{"title":"Page","path":"/page/index.html","content":"This is a page test."},{"title":"朋友文章","path":"/friends/rss/index.html","content":""},{"title":"关于","path":"/about/index.html","content":"友链关于昵称简介 关于本站 本站没有任何推广和打赏链接，如果您觉得哪个作品不错，欢迎去对应的仓库点个赞，或者在对应的文章下面留言互动一下。 开源项目无任何盈利目的，只在工作闲暇时间进行维护，有相关需求请前往对应项目提 Issue 进行反馈，通过私人邮件询问开源项目问题可能得不到答复。"}]